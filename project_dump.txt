################################################################################
# PROJECT DUMP
# Root: C:\Users\Sultan\Downloads\parkshare_ru_part1
# Generated at: 2025-11-22 14:36:32
################################################################################
PROJECT TREE:
--------------------------------------------------------------------------------
parkshare_ru_part1/
    .env
    .env.example
    .gitattributes
    .gitignore
    Dockerfile
    README.md
    docker-compose.yml
    dump_project.py
    entrypoint.sh
    project_dump.txt
    requirements.txt
    accounts/
        __init__.py
        admin.py
        apps.py
        auth.py
        forms.py
        models.py
        serializers.py
        urls.py
        views.py
        migrations/
            0001_initial.py
            __init__.py
    ai/
        __init__.py
        admin.py
        apps.py
        features.py
        models.py
        pricing.py
        serializers.py
        tasks.py
        views.py
    backend/
        manage.py
        backend/
            __init__.py
            config/
                __init__.py
                asgi.py
                celery.py
                urls.py
                wsgi.py
            settings/
                __init__.py
                base.py
                local.py
                production.py
        tests/
            __init__.py
            test_auth_api.py
            test_booking_model.py
    core/
        __init__.py
        admin.py
        apps.py
        models.py
        pagination.py
        permissions.py
        utils.py
    nginx/
        nginx.conf
    parking/
        __init__.py
        admin.py
        apps.py
        models.py
        serializers.py
        tasks.py
        urls.py
        views.py
        migrations/
            0001_initial.py
            0002_parkinglot_stress_index_parkingspot_occupancy_7d.py
            __init__.py
    payments/
        __init__.py
        admin.py
        apps.py
        models.py
        providers.py
        serializers.py
        tasks.py
        views.py
        migrations/
            0001_initial.py
            __init__.py
        providers/
            __init__.py
            base.py
            yookassa.py
    static/
        manifest.webmanifest
        service-worker.js
        css/
            app.css
        icons/
        js/
            app.js
    templates/
        base.html
        offline.html
        accounts/
            login.html
            password_change.html
            password_change_done.html
            password_reset.html
            password_reset_complete.html
            password_reset_confirm.html
            password_reset_done.html
            password_reset_email.txt
            password_reset_subject.txt
            profile.html
            register.html
        parking/
            landing.html
            owner_dashboard.html
            user_dashboard.html
    vehicles/
        __init__.py
        admin.py
        apps.py
        models.py
        serializers.py
        urls.py
        views.py
        migrations/
            0001_initial.py
            __init__.py


================================================================================
FILES CONTENT:
================================================================================

################################################################################
# File: .env
################################################################################

# -----------------------------
# DJANGO SETTINGS
# -----------------------------
DEBUG=1
SECRET_KEY=django-insecure-test-secret-key-for-dev-only
ALLOWED_HOSTS=127.0.0.1,localhost

# -----------------------------
# DATABASE (SQLite)
# -----------------------------
DATABASE_NAME=db.sqlite3

# -----------------------------
# YOOKASSA PAYMENTS
# (можно оставить пустыми — тогда просто не будет работать платежка)
# -----------------------------
YOOKASSA_SHOP_ID=
YOOKASSA_SECRET_KEY=

# -----------------------------
# EMAIL SETTINGS (можно не трогать)
# -----------------------------
EMAIL_BACKEND=django.core.mail.backends.console.EmailBackend


MAPBOX_TOKEN=your_actual_token_here

################################################################################
# File: .env.example
################################################################################

# Базовые настройки Django
DEBUG=True
SECRET_KEY=change_me_to_random_long_secret_key
ALLOWED_HOSTS=localhost,127.0.0.1,0.0.0.0

# База данных
# Для продакшена: postgres://user:password@db:5432/parkshare
# Django-environ автоматически распарсит URL.
DATABASE_URL=sqlite:///db.sqlite3

# Redis (брокер/кэш)
REDIS_URL=redis://redis:6379/0

# Таймзона и язык
TIME_ZONE=Europe/Moscow
LANGUAGE_CODE=ru-ru

# Соль для хэширования цифр номеров
VEHICLE_PLATE_SALT=change_me_vehicle_plate_salt

# Настройки CORS (если нужен доступ с другого домена, например, моб. WebView)
CORS_ALLOWED_ORIGINS=http://localhost:8000

# Настройки Celery
CELERY_BROKER_URL=${REDIS_URL}
CELERY_RESULT_BACKEND=${REDIS_URL}

# Настройки YooKassa (пример)
YOOKASSA_SHOP_ID=your_shop_id_here
YOOKASSA_SECRET_KEY=your_secret_key_here
YOOKASSA_RETURN_URL=https://example.com/payments/return/
YOOKASSA_WEBHOOK_SECRET=change_me_webhook_secret

# Комиссия сервиса (процент, будет использована в бизнес-логике)
SERVICE_COMMISSION_PERCENT=10

# Безопасность для продакшена
SECURE_SSL_REDIRECT=False
SESSION_COOKIE_SECURE=False
CSRF_COOKIE_SECURE=False


################################################################################
# File: .gitattributes
################################################################################

# Auto detect text files and perform LF normalization
* text=auto


################################################################################
# File: .gitignore
################################################################################

.env
node_modules/
.DS_Store
*.log
dist/

################################################################################
# File: Dockerfile
################################################################################

FROM python:3.11-bullseye

ENV PYTHONUNBUFFERED=1 \
    PYTHONDONTWRITEBYTECODE=1 \
    PIP_NO_CACHE_DIR=off \
    PIP_DISABLE_PIP_VERSION_CHECK=on \
    PIP_DEFAULT_TIMEOUT=100

# Системные зависимости для Postgres, GDAL/GEOS (на будущее) и компиляции
RUN apt-get update && apt-get install -y --no-install-recommends \
    build-essential \
    libpq-dev \
    gdal-bin \
    libgdal-dev \
    binutils \
    libproj-dev \
    libgeos-dev \
    libspatialindex-dev \
    gettext \
    && rm -rf /var/lib/apt/lists/*

# Настройки GDAL/PROJ (если когда-нибудь добавишь GeoDjango)
ENV GDAL_LIBRARY_PATH=/usr/lib/libgdal.so
ENV PROJ_LIB=/usr/share/proj

WORKDIR /app

# Устанавливаем зависимости
COPY requirements.txt /app/
RUN pip install --upgrade pip && pip install -r requirements.txt

# Копируем проект
COPY . /app/

# Каталоги для статики и медиа
RUN mkdir -p /app/staticfiles /app/media

EXPOSE 8000

# По умолчанию — gunicorn, но в docker-compose мы переопределим команду
CMD ["gunicorn", "backend.config.wsgi:application", "--bind", "0.0.0.0:8000"]


################################################################################
# File: README.md
################################################################################

# parkshare



################################################################################
# File: docker-compose.yml
################################################################################

version: "3.9"

services:
  db:
    image: postgis/postgis:16-3.4
    container_name: parkshare_db
    restart: always
    environment:
      POSTGRES_DB: parkshare
      POSTGRES_USER: parkshare
      POSTGRES_PASSWORD: parkshare
    volumes:
      - postgres_data:/var/lib/postgresql/data
    networks:
      - parkshare_net

  redis:
    image: redis:7-alpine
    container_name: parkshare_redis
    restart: always
    networks:
      - parkshare_net

  web:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: parkshare_web
    restart: always
    env_file:
      - .env  # можно потом заменить на .env.prod
    command: /app/entrypoint.sh
    volumes:
      - .:/app
      - static_volume:/app/staticfiles
      - media_volume:/app/media
    depends_on:
      - db
      - redis
    networks:
      - parkshare_net

  worker:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: parkshare_worker
    restart: always
    env_file:
      - .env
    command: celery -A backend.config worker -l info
    volumes:
      - .:/app
    depends_on:
      - db
      - redis
    networks:
      - parkshare_net

  beat:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: parkshare_beat
    restart: always
    env_file:
      - .env
    command: celery -A backend.config beat -l info
    volumes:
      - .:/app
    depends_on:
      - db
      - redis
    networks:
      - parkshare_net

  nginx:
    image: nginx:alpine
    container_name: parkshare_nginx
    restart: always
    ports:
      - "80:80"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - static_volume:/static
      - media_volume:/media
    depends_on:
      - web
    networks:
      - parkshare_net

volumes:
  postgres_data:
  static_volume:
  media_volume:

networks:
  parkshare_net:
    driver: bridge


################################################################################
# File: dump_project.py
################################################################################

import os
from datetime import datetime

# Какие папки игнорировать (чтобы не тащить venv, медиа, кэш и т.п.)
EXCLUDED_DIRS = {
    ".git",
    ".venv",
    "venv",
    "__pycache__",
    "node_modules",
    "dist",
    "build",
    "staticfiles",
    "media",
    ".idea",
    ".vscode",
}

# Какие расширения файлов пропускать (бинарные и тяжёлые)
IGNORED_EXTENSIONS = {
    ".pyc",
    ".pyo",
    ".pyd",
    ".db",
    ".sqlite3",
    ".sqlite",
    ".png",
    ".jpg",
    ".jpeg",
    ".gif",
    ".ico",
    ".pdf",
    ".zip",
    ".rar",
    ".7z",
    ".exe",
    ".dll",
    ".so",
}


def is_binary_file(filename: str) -> bool:
    _, ext = os.path.splitext(filename.lower())
    return ext in IGNORED_EXTENSIONS


def build_tree_and_collect_files(root: str):
    """
    Обходит проект, строит дерево директорий и собирает список файлов,
    которые потом будем выгружать целиком.
    """
    tree_lines = []
    file_paths = []

    root = os.path.abspath(root)
    root_name = os.path.basename(root.rstrip(os.sep))

    # Добавляем корень один раз
    tree_lines.append(f"{root_name}/")

    for current_root, dirs, files in os.walk(root):
        # Отбрасываем ненужные директории
        dirs[:] = [
            d for d in dirs
            if d not in EXCLUDED_DIRS and not d.startswith(".")
        ]

        rel_root = os.path.relpath(current_root, root)
        if rel_root == ".":
            depth = 0
        else:
            depth = rel_root.count(os.sep) + 1

        indent = "    " * depth

        if rel_root != ".":
            tree_lines.append(f"{indent}{os.path.basename(current_root)}/")

        # Файлы
        for name in sorted(files):
            if is_binary_file(name):
                continue
            file_rel_path = os.path.join(rel_root, name) if rel_root != "." else name
            file_abs_path = os.path.join(current_root, name)

            tree_lines.append(f"{indent}    {name}")
            file_paths.append((file_rel_path, file_abs_path))

    return tree_lines, file_paths


def dump_project(root: str, output_filename: str = "project_dump.txt"):
    tree_lines, file_paths = build_tree_and_collect_files(root)

    root = os.path.abspath(root)
    header = [
        "#" * 80,
        "# PROJECT DUMP",
        f"# Root: {root}",
        f"# Generated at: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
        "#" * 80,
        "",
    ]

    with open(output_filename, "w", encoding="utf-8", errors="replace") as f:
        # Шапка
        f.write("\n".join(header))

        # Дерево проекта
        f.write("PROJECT TREE:\n")
        f.write("-" * 80 + "\n")
        for line in tree_lines:
            f.write(line + "\n")

        # Разделитель
        f.write("\n\n")
        f.write("=" * 80 + "\n")
        f.write("FILES CONTENT:\n")
        f.write("=" * 80 + "\n\n")

        # Содержимое файлов
        for rel_path, abs_path in file_paths:
            f.write("#" * 80 + "\n")
            f.write(f"# File: {rel_path}\n")
            f.write("#" * 80 + "\n\n")

            try:
                with open(abs_path, "r", encoding="utf-8", errors="replace") as src:
                    f.write(src.read())
            except Exception as e:
                f.write(f"<< ERROR READING FILE: {e} >>\n")

            f.write("\n\n")

    print(f"Готово! Файл с дампом проекта: {output_filename}")


if __name__ == "__main__":
    # Точка входа: текущая папка — корень проекта (parkshare_ru_pwa)
    project_root = os.path.dirname(os.path.abspath(__file__))
    dump_project(project_root)


################################################################################
# File: entrypoint.sh
################################################################################

sh -c "python backend/manage.py migrate &&
             python backend/manage.py collectstatic --noinput &&
             gunicorn backend.config.wsgi:application --bind 0.0.0.0:8000"

################################################################################
# File: project_dump.txt
################################################################################



################################################################################
# File: requirements.txt
################################################################################

Django==5.2.8
djangorestframework==3.16.1
django-environ==0.12.0
django-cors-headers==4.9.0
django-cryptography-django5==2.2
psycopg[binary]==3.2.12
celery==5.5.3
redis==7.0.1
Pillow==11.1.0
numpy==2.3.0
pandas==2.2.3
scikit-learn==1.7.2
gunicorn==23.0.0
yookassa
drf-spectacular==0.27.2


################################################################################
# File: accounts\__init__.py
################################################################################



################################################################################
# File: accounts\admin.py
################################################################################

# accounts/admin.py

from django.contrib import admin
from django.contrib.auth.admin import UserAdmin as DjangoUserAdmin

from .models import User


@admin.register(User)
class UserAdmin(DjangoUserAdmin):
    """
    Кастомная админка для пользователя с UUID-ID и ролями.
    """

    fieldsets = DjangoUserAdmin.fieldsets + (
        (
            "Дополнительно",
            {
                "fields": (
                    "role",
                    "email_encrypted",
                    "phone_encrypted",
                    "owner_request_pending",
                )
            },
        ),
    )

    list_display = (
        "username",
        "role",
        "is_active",
        "is_staff",
        "is_superuser",
        "date_joined",
    )
    list_filter = ("role", "is_active", "is_staff", "is_superuser")
    search_fields = ("username",)


################################################################################
# File: accounts\apps.py
################################################################################

# accounts/apps.py

from django.apps import AppConfig


class AccountsConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "accounts"
    verbose_name = "Пользователи ParkShare"


################################################################################
# File: accounts\auth.py
################################################################################

# accounts/auth.py

from __future__ import annotations

from typing import Optional

from django.contrib.auth import get_user_model

from core.utils import normalize_phone

User = get_user_model()


def find_user_by_identifier(identifier: str) -> Optional[User]:
    """
    Возвращает пользователя по логину / email / телефону.

    Используется в HTML-форме логина и в API.
    """
    if not identifier:
        return None

    ident = identifier.strip()
    qs = User.objects.filter(is_active=True)

    # 1) Email
    if "@" in ident:
        email = ident.lower()
        try:
            return qs.get(email_encrypted=email)
        except User.DoesNotExist:
            return None
        except User.MultipleObjectsReturned:
            return qs.filter(email_encrypted=email).order_by("date_joined").first()

    # 2) Телефон
    phone = normalize_phone(ident)
    if phone:
        user = qs.filter(phone_encrypted=phone).order_by("date_joined").first()
        if user:
            return user

    # 3) Логин
    try:
        return qs.get(username__iexact=ident)
    except User.DoesNotExist:
        return None
    except User.MultipleObjectsReturned:
        return qs.filter(username__iexact=ident).order_by("date_joined").first()


################################################################################
# File: accounts\forms.py
################################################################################

# accounts/forms.py

from typing import Any

from django import forms
from django.contrib.auth.forms import AuthenticationForm, UserCreationForm
from django.utils.translation import gettext_lazy as _

from core.utils import normalize_phone
from .models import User


class LoginForm(AuthenticationForm):
    """
    Форма входа: одно поле для логина / email / телефона + пароль.
    """

    username = forms.CharField(
        label=_("Логин / Email / Телефон"),
        widget=forms.TextInput(attrs={"autofocus": True, "class": "ps-input"}),
    )

    def clean(self):
        """
        Подменяем username на реальный логин пользователя, чтобы
        AuthenticationForm могла вызвать authenticate() как обычно.
        """
        from .auth import find_user_by_identifier  # локальный импорт

        identifier = self.cleaned_data.get("username")
        password = self.cleaned_data.get("password")

        if identifier and password:
            user = find_user_by_identifier(identifier)
            if user is not None:
                self.cleaned_data["username"] = user.get_username()

        return super().clean()


class RegisterForm(UserCreationForm):
    """
    Регистрация через HTML-форму.
    Email и телефон — опциональные, сохраняются в зашифрованном виде.
    """

    email = forms.EmailField(
        label=_("Email (опционально)"),
        required=False,
        widget=forms.EmailInput(attrs={"class": "ps-input"}),
    )
    phone = forms.CharField(
        label=_("Телефон (опционально)"),
        required=False,
        widget=forms.TextInput(attrs={"class": "ps-input"}),
    )

    class Meta(UserCreationForm.Meta):
        model = User
        fields = ("username", "email", "phone")
        widgets = {
            "username": forms.TextInput(attrs={"class": "ps-input"}),
        }

    def clean_email(self) -> str:
        email = (self.cleaned_data.get("email") or "").strip()
        if not email:
            return ""
        email = email.lower()
        if User.objects.filter(email_encrypted=email).exists():
            raise forms.ValidationError(
                _("Пользователь с таким email уже зарегистрирован.")
            )
        return email

    def clean_phone(self) -> str:
        phone = self.cleaned_data.get("phone")
        if not phone:
            return ""
        phone_norm = normalize_phone(phone)
        if User.objects.filter(phone_encrypted=phone_norm).exists():
            raise forms.ValidationError(
                _("Пользователь с таким телефоном уже зарегистрирован.")
            )
        return phone_norm

    def save(self, commit: bool = True) -> User:
        user: User = super().save(commit=False)
        email = self.cleaned_data.get("email") or ""
        phone = self.cleaned_data.get("phone") or ""
        if email:
            user.email_plain = email
        if phone:
            user.phone_plain = phone
        if commit:
            user.save()
        return user


class ProfileForm(forms.ModelForm):
    """
    Редактирование профиля (email/телефон).
    """

    email = forms.EmailField(
        label=_("Email"),
        required=False,
        widget=forms.EmailInput(attrs={"class": "ps-input"}),
    )
    phone = forms.CharField(
        label=_("Телефон"),
        required=False,
        widget=forms.TextInput(attrs={"class": "ps-input"}),
    )

    class Meta:
        model = User
        fields = ("email", "phone")

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        user: User | None = kwargs.get("instance")
        if user is not None:
            initial = kwargs.setdefault("initial", {})
            initial.setdefault("email", user.email_plain)
            initial.setdefault("phone", user.phone_plain)
        super().__init__(*args, **kwargs)

    def clean_email(self) -> str:
        email = (self.cleaned_data.get("email") or "").strip()
        if not email:
            return ""
        email = email.lower()
        qs = User.objects.filter(email_encrypted=email)
        if self.instance.pk:
            qs = qs.exclude(pk=self.instance.pk)
        if qs.exists():
            raise forms.ValidationError(
                _("Пользователь с таким email уже зарегистрирован.")
            )
        return email

    def clean_phone(self) -> str:
        phone = self.cleaned_data.get("phone")
        if not phone:
            return ""
        phone_norm = normalize_phone(phone)
        qs = User.objects.filter(phone_encrypted=phone_norm)
        if self.instance.pk:
            qs = qs.exclude(pk=self.instance.pk)
        if qs.exists():
            raise forms.ValidationError(
                _("Пользователь с таким телефоном уже зарегистрирован.")
            )
        return phone_norm

    def save(self, commit: bool = True) -> User:
        user: User = super().save(commit=False)
        email = self.cleaned_data.get("email") or ""
        phone = self.cleaned_data.get("phone") or ""
        user.email_plain = email
        user.phone_plain = phone
        if commit:
            user.save()
        return user


################################################################################
# File: accounts\models.py
################################################################################

# accounts/models.py

import uuid

from django.contrib.auth.models import AbstractUser
from django.db import models
from django.utils.translation import gettext_lazy as _
from django_cryptography.fields import encrypt


class User(AbstractUser):
    """
    Кастомный пользователь:
    - UUID как первичный ключ;
    - роль (driver / owner / admin);
    - email/телефон в зашифрованном виде (django-cryptography-django5).
    """

    class Role(models.TextChoices):
        DRIVER = "driver", _("Водитель")
        OWNER = "owner", _("Владелец парковки")
        ADMIN = "admin", _("Администратор")

    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)

    role = models.CharField(
        _("Роль"),
        max_length=16,
        choices=Role.choices,
        default=Role.DRIVER,
        help_text=_("Определяет права доступа в системе."),
    )

    email_encrypted = encrypt(
        models.EmailField(
            _("Email (зашифрованный)"),
            blank=True,
            null=True,
            help_text=_("Опциональный email, хранится в зашифрованном виде."),
        )
    )

    phone_encrypted = encrypt(
        models.CharField(
            _("Телефон (зашифрованный)"),
            max_length=32,
            blank=True,
            null=True,
            help_text=_("Опциональный телефон, хранится в зашифрованном виде."),
        )
    )

    owner_request_pending = models.BooleanField(
        _("Запрошено повышение до владельца"),
        default=False,
        help_text=_("Пользователь подал заявку на роль владельца парковки."),
    )

    # username + password остаются стандартными полями AbstractUser
    REQUIRED_FIELDS: list[str] = []

    class Meta:
        verbose_name = _("Пользователь")
        verbose_name_plural = _("Пользователи")

    def __str__(self) -> str:
        return self.username

    # Удобные свойства для расшифрованных контактов

    @property
    def email_plain(self) -> str:
        """
        Удобное свойство для доступа к расшифрованному email.
        В коде (и в админке) можно использовать user.email_plain.
        """
        return self.email_encrypted or ""

    @email_plain.setter
    def email_plain(self, value: str) -> None:
        self.email_encrypted = value

    @property
    def phone_plain(self) -> str:
        return self.phone_encrypted or ""

    @phone_plain.setter
    def phone_plain(self, value: str) -> None:
        self.phone_encrypted = value

    @property
    def is_driver(self) -> bool:
        return self.role == self.Role.DRIVER

    @property
    def is_owner(self) -> bool:
        return self.role in (self.Role.OWNER, self.Role.ADMIN)

    @property
    def is_admin(self) -> bool:
        return self.role == self.Role.ADMIN or self.is_superuser


################################################################################
# File: accounts\serializers.py
################################################################################

# accounts/serializers.py

from django.contrib.auth import authenticate
from django.contrib.auth.password_validation import validate_password
from django.utils.translation import gettext_lazy as _
from rest_framework import serializers

from core.utils import normalize_phone
from .auth import find_user_by_identifier
from .models import User


class UserSerializer(serializers.ModelSerializer):
    """
    Базовое представление пользователя для админских API.
    Контактные данные не раскрываются.
    """

    has_email = serializers.SerializerMethodField()
    has_phone = serializers.SerializerMethodField()

    class Meta:
        model = User
        fields = (
            "id",
            "username",
            "role",
            "is_active",
            "date_joined",
            "has_email",
            "has_phone",
        )

    def get_has_email(self, obj: User) -> bool:
        return bool(obj.email_plain)

    def get_has_phone(self, obj: User) -> bool:
        return bool(obj.phone_plain)


class UserProfileSerializer(serializers.ModelSerializer):
    """
    Профиль текущего пользователя.
    Здесь можно редактировать email/телефон.
    """

    email = serializers.CharField(
        source="email_plain", allow_blank=True, required=False
    )
    phone = serializers.CharField(
        source="phone_plain", allow_blank=True, required=False
    )

    class Meta:
        model = User
        fields = ("id", "username", "role", "email", "phone")

    def validate_phone(self, value: str) -> str:
        value = normalize_phone(value)
        user = self.instance
        if not value:
            return ""
        qs = User.objects.filter(phone_encrypted=value)
        if user is not None:
            qs = qs.exclude(pk=user.pk)
        if qs.exists():
            raise serializers.ValidationError(
                _("Пользователь с таким телефоном уже существует.")
            )
        return value

    def validate_email(self, value: str) -> str:
        value = (value or "").strip().lower()
        if not value:
            return ""
        user = self.instance
        qs = User.objects.filter(email_encrypted=value)
        if user is not None:
            qs = qs.exclude(pk=user.pk)
        if qs.exists():
            raise serializers.ValidationError(
                _("Пользователь с таким email уже существует.")
            )
        return value


class RegisterSerializer(serializers.Serializer):
    """
    Регистрация через API.
    """

    username = serializers.CharField(max_length=150)
    password = serializers.CharField(write_only=True, min_length=8)
    email = serializers.EmailField(required=False, allow_blank=True)
    phone = serializers.CharField(required=False, allow_blank=True)

    def validate_username(self, value: str) -> str:
        if User.objects.filter(username=value).exists():
            raise serializers.ValidationError(
                _("Пользователь с таким логином уже существует.")
            )
        return value

    def validate_email(self, value: str) -> str:
        value = (value or "").strip().lower()
        if not value:
            return ""
        if User.objects.filter(email_encrypted=value).exists():
            raise serializers.ValidationError(
                _("Пользователь с таким email уже зарегистрирован.")
            )
        return value

    def validate_phone(self, value: str) -> str:
        value = normalize_phone(value)
        if not value:
            return ""
        if User.objects.filter(phone_encrypted=value).exists():
            raise serializers.ValidationError(
                _("Пользователь с таким телефоном уже зарегистрирован.")
            )
        return value

    def validate_password(self, value: str) -> str:
        validate_password(value)
        return value

    def create(self, validated_data: dict) -> User:
        email = validated_data.pop("email", "")
        phone = validated_data.pop("phone", "")
        user = User(username=validated_data["username"])
        user.set_password(validated_data["password"])
        if email:
            user.email_plain = email
        if phone:
            user.phone_plain = phone
        user.save()
        return user


class LoginSerializer(serializers.Serializer):
    """
    Логин через API (session-based).
    Позволяет использовать логин, email или телефон.
    """

    identifier = serializers.CharField(
        label=_("Логин / Email / Телефон"),
    )
    password = serializers.CharField(write_only=True)

    def validate(self, attrs: dict) -> dict:
        identifier = attrs.get("identifier")
        password = attrs.get("password")

        if not identifier or not password:
            raise serializers.ValidationError(
                _("Необходимо указать логин и пароль."), code="authorization"
            )

        user = find_user_by_identifier(identifier)
        if not user or not user.check_password(password):
            raise serializers.ValidationError(
                _("Неверный логин (имя, email или телефон) или пароль."),
                code="authorization",
            )

        if not user.is_active:
            raise serializers.ValidationError(
                _("Пользователь деактивирован."), code="authorization"
            )

        attrs["user"] = user
        return attrs


class ChangePasswordSerializer(serializers.Serializer):
    """
    Смена пароля текущего пользователя.
    """

    old_password = serializers.CharField(write_only=True)
    new_password = serializers.CharField(write_only=True, min_length=8)

    def validate_new_password(self, value: str) -> str:
        user = self.context["request"].user
        validate_password(value, user=user)
        return value

    def validate(self, attrs: dict) -> dict:
        user = self.context["request"].user
        old_password = attrs.get("old_password")
        if not user.check_password(old_password):
            raise serializers.ValidationError(
                {"old_password": _("Неверный текущий пароль.")}
            )
        return attrs

    def save(self, **kwargs) -> User:
        user = self.context["request"].user
        new_password = self.validated_data["new_password"]
        user.set_password(new_password)
        user.save(update_fields=["password"])
        return user


class PasswordResetRequestSerializer(serializers.Serializer):
    """
    Запрос на сброс пароля по email (API).
    """

    email = serializers.EmailField()

    def validate_email(self, value: str) -> str:
        value = (value or "").strip().lower()
        # В целях безопасности не раскрываем, существует ли пользователь.
        return value


################################################################################
# File: accounts\urls.py
################################################################################

# accounts/urls.py

from django.contrib.auth import views as auth_views
from django.urls import path, reverse_lazy

from .views import CustomLoginView, ProfileView, RegisterView, logout_view

app_name = "accounts"

urlpatterns = [
    path("login/", CustomLoginView.as_view(), name="login"),
    path("logout/", logout_view, name="logout"),
    path("register/", RegisterView.as_view(), name="register"),
    path("profile/", ProfileView.as_view(), name="profile"),

    # Смена пароля (HTML)
    path(
        "password/change/",
        auth_views.PasswordChangeView.as_view(
            template_name="accounts/password_change.html",
            success_url=reverse_lazy("accounts:password_change_done"),
        ),
        name="password_change",
    ),
    path(
        "password/change/done/",
        auth_views.PasswordChangeDoneView.as_view(
            template_name="accounts/password_change_done.html"
        ),
        name="password_change_done",
    ),

    # Сброс пароля (HTML)
    path(
        "password/reset/",
        auth_views.PasswordResetView.as_view(
            template_name="accounts/password_reset.html",
            email_template_name="accounts/password_reset_email.txt",
            subject_template_name="accounts/password_reset_subject.txt",
            success_url=reverse_lazy("accounts:password_reset_done"),
        ),
        name="password_reset",
    ),
    path(
        "password/reset/done/",
        auth_views.PasswordResetDoneView.as_view(
            template_name="accounts/password_reset_done.html"
        ),
        name="password_reset_done",
    ),
    path(
        "reset/<uidb64>/<token>/",
        auth_views.PasswordResetConfirmView.as_view(
            template_name="accounts/password_reset_confirm.html",
            success_url=reverse_lazy("accounts:password_reset_complete"),
        ),
        name="password_reset_confirm",
    ),
    path(
        "reset/done/",
        auth_views.PasswordResetCompleteView.as_view(
            template_name="accounts/password_reset_complete.html"
        ),
        name="password_reset_complete",
    ),
]


################################################################################
# File: accounts\views.py
################################################################################

# accounts/views.py

from typing import Any

from django.contrib.auth import login as auth_login, logout as auth_logout
from django.contrib.auth.mixins import LoginRequiredMixin
from django.contrib.auth.views import LoginView as DjangoLoginView
from django.contrib.auth.forms import PasswordResetForm
from django.http import HttpRequest, HttpResponse
from django.shortcuts import redirect, render
from django.urls import reverse, reverse_lazy
from django.views import View
from django.views.generic import UpdateView
from rest_framework import permissions, status, viewsets
from rest_framework.decorators import action
from rest_framework.response import Response

from core.permissions import IsSelfOrAdmin
from .forms import LoginForm, ProfileForm, RegisterForm
from .models import User
from .serializers import (
    ChangePasswordSerializer,
    LoginSerializer,
    PasswordResetRequestSerializer,
    RegisterSerializer,
    UserProfileSerializer,
    UserSerializer,
)


# ===== HTML-вьюхи (шаблонный интерфейс) =====


class RegisterView(View):
    """
    Регистрация пользователя через HTML-форму.
    """

    template_name = "accounts/register.html"

    def get(self, request: HttpRequest) -> HttpResponse:
        if request.user.is_authenticated:
            return redirect("user_dashboard")
        form = RegisterForm()
        return render(request, self.template_name, {"form": form})

    def post(self, request: HttpRequest) -> HttpResponse:
        if request.user.is_authenticated:
            return redirect("user_dashboard")
        form = RegisterForm(request.POST)
        if form.is_valid():
            user = form.save()
            auth_login(request, user)
            return redirect("user_dashboard")
        return render(request, self.template_name, {"form": form})


class ProfileView(LoginRequiredMixin, UpdateView):
    """
    Редактирование профиля (email/телефон) в HTML-интерфейсе.
    """

    model = User
    form_class = ProfileForm
    template_name = "accounts/profile.html"
    success_url = reverse_lazy("user_dashboard")

    def get_object(self, queryset=None) -> User:
        return self.request.user


class CustomLoginView(DjangoLoginView):
    """
    Обёртка над стандартным LoginView с русским шаблоном и кастомной формой.
    """

    template_name = "accounts/login.html"
    form_class = LoginForm

    def get_success_url(self) -> str:
        return reverse("user_dashboard")


def logout_view(request: HttpRequest) -> HttpResponse:
    auth_logout(request)
    return redirect("landing")


# ===== API (DRF) =====


class UserViewSet(viewsets.ModelViewSet):
    """
    API для работы с пользователями.

    Маршруты:
    - /api/accounts/users/                   (GET)   — список (только админ)
    - /api/accounts/users/{id}/              (GET)   — профиль (сам или админ)
    - /api/accounts/users/me/                (GET)   — профиль текущего пользователя
    - /api/accounts/users/me/                (PATCH) — обновление своего профиля
    - /api/accounts/users/register/          (POST)  — регистрация
    - /api/accounts/users/login/             (POST)  — логин (session-based)
    - /api/accounts/users/logout/            (POST)  — логаут
    - /api/accounts/users/change-password/   (POST)  — смена пароля (API)
    - /api/accounts/users/reset-password/    (POST)  — запрос сброса пароля по email
    """

    queryset = User.objects.all().order_by("-date_joined")
    serializer_class = UserSerializer

    def get_permissions(self) -> list[Any]:
        if self.action in ("register", "login", "reset_password"):
            permission_classes = [permissions.AllowAny]
        elif self.action in ("list", "destroy"):
            permission_classes = [permissions.IsAdminUser]
        elif self.action in ("me", "change_password", "logout"):
            permission_classes = [permissions.IsAuthenticated]
        else:
            # retrieve/update/partial_update — только сам пользователь или админ
            permission_classes = [permissions.IsAuthenticated, IsSelfOrAdmin]
        return [perm() for perm in permission_classes]

    def get_queryset(self):
        user: User = self.request.user
        if not user.is_authenticated:
            return User.objects.none()
        if user.is_superuser or getattr(user, "is_admin", False):
            return User.objects.all().order_by("-date_joined")
        return User.objects.filter(pk=user.pk)

    def perform_destroy(self, instance: User) -> None:
        """
        Удалять пользователей может только админ — контролируется permissions.
        """
        super().perform_destroy(instance)

    @action(detail=False, methods=["get", "patch"], url_path="me")
    def me(self, request):
        """
        Профиль текущего пользователя.
        GET — получить; PATCH — обновить email/телефон.
        """
        if request.method.lower() == "get":
            serializer = UserProfileSerializer(request.user)
            return Response(serializer.data)
        serializer = UserProfileSerializer(
            request.user, data=request.data, partial=True
        )
        serializer.is_valid(raise_exception=True)
        serializer.save()
        return Response(serializer.data)

    @action(detail=False, methods=["post"], url_path="register")
    def register(self, request):
        """
        Регистрация пользователя через API.
        """
        serializer = RegisterSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        user: User = serializer.save()
        auth_login(request, user)
        data = UserProfileSerializer(user).data
        return Response(data, status=status.HTTP_201_CREATED)

    @action(detail=False, methods=["post"], url_path="login")
    def login(self, request):
        """
        Логин через API. Используются стандартные Django-сессии.
        """
        serializer = LoginSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        user: User = serializer.validated_data["user"]
        auth_login(request, user)
        data = UserProfileSerializer(user).data
        return Response(data, status=status.HTTP_200_OK)

    @action(detail=False, methods=["post"], url_path="logout")
    def logout(self, request):
        """
        Логаут через API (очистка сессии).
        """
        auth_logout(request)
        return Response(
            {"detail": "Вы вышли из системы."}, status=status.HTTP_200_OK
        )

    @action(detail=False, methods=["post"], url_path="change-password")
    def change_password(self, request):
        """
        Смена пароля текущего пользователя (API).
        """
        serializer = ChangePasswordSerializer(
            data=request.data, context={"request": request}
        )
        serializer.is_valid(raise_exception=True)
        serializer.save()
        return Response(
            {"detail": "Пароль успешно изменён."},
            status=status.HTTP_200_OK,
        )

    @action(detail=False, methods=["post"], url_path="reset-password")
    def reset_password(self, request):
        """
        Запрос на сброс пароля по email (API).

        Использует стандартный PasswordResetForm и отправляет письмо
        через настроенный EMAIL_BACKEND.
        """
        serializer = PasswordResetRequestSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        email = serializer.validated_data["email"]

        form = PasswordResetForm(data={"email": email})
        if form.is_valid():
            form.save(
                request=request,
                use_https=request.is_secure(),
                email_template_name="accounts/password_reset_email.txt",
                subject_template_name="accounts/password_reset_subject.txt",
            )

        # Независимо от результата говорим одно и то же, чтобы не раскрывать,
        # существует ли пользователь с таким email.
        return Response(
            {
                "detail": (
                    "Если пользователь с таким email существует, на него отправлена "
                    "инструкция по сбросу пароля."
                )
            },
            status=status.HTTP_200_OK,
        )


################################################################################
# File: accounts\migrations\0001_initial.py
################################################################################

# Generated by Django 5.2.8 on 2025-11-21 21:34

import django.contrib.auth.models
import django.contrib.auth.validators
import django.utils.timezone
import django_cryptography.fields
import uuid
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('auth', '0012_alter_user_first_name_max_length'),
    ]

    operations = [
        migrations.CreateModel(
            name='User',
            fields=[
                ('password', models.CharField(max_length=128, verbose_name='password')),
                ('last_login', models.DateTimeField(blank=True, null=True, verbose_name='last login')),
                ('is_superuser', models.BooleanField(default=False, help_text='Designates that this user has all permissions without explicitly assigning them.', verbose_name='superuser status')),
                ('username', models.CharField(error_messages={'unique': 'A user with that username already exists.'}, help_text='Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.', max_length=150, unique=True, validators=[django.contrib.auth.validators.UnicodeUsernameValidator()], verbose_name='username')),
                ('first_name', models.CharField(blank=True, max_length=150, verbose_name='first name')),
                ('last_name', models.CharField(blank=True, max_length=150, verbose_name='last name')),
                ('email', models.EmailField(blank=True, max_length=254, verbose_name='email address')),
                ('is_staff', models.BooleanField(default=False, help_text='Designates whether the user can log into this admin site.', verbose_name='staff status')),
                ('is_active', models.BooleanField(default=True, help_text='Designates whether this user should be treated as active. Unselect this instead of deleting accounts.', verbose_name='active')),
                ('date_joined', models.DateTimeField(default=django.utils.timezone.now, verbose_name='date joined')),
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('role', models.CharField(choices=[('driver', 'Водитель'), ('owner', 'Владелец парковки'), ('admin', 'Администратор')], default='driver', help_text='Определяет права доступа в системе.', max_length=16, verbose_name='Роль')),
                ('email_encrypted', django_cryptography.fields.encrypt(models.EmailField(blank=True, help_text='Опциональный email, хранится в зашифрованном виде.', max_length=254, null=True, verbose_name='Email (зашифрованный)'))),
                ('phone_encrypted', django_cryptography.fields.encrypt(models.CharField(blank=True, help_text='Опциональный телефон, хранится в зашифрованном виде.', max_length=32, null=True, verbose_name='Телефон (зашифрованный)'))),
                ('owner_request_pending', models.BooleanField(default=False, help_text='Пользователь подал заявку на роль владельца парковки.', verbose_name='Запрошено повышение до владельца')),
                ('groups', models.ManyToManyField(blank=True, help_text='The groups this user belongs to. A user will get all permissions granted to each of their groups.', related_name='user_set', related_query_name='user', to='auth.group', verbose_name='groups')),
                ('user_permissions', models.ManyToManyField(blank=True, help_text='Specific permissions for this user.', related_name='user_set', related_query_name='user', to='auth.permission', verbose_name='user permissions')),
            ],
            options={
                'verbose_name': 'Пользователь',
                'verbose_name_plural': 'Пользователи',
            },
            managers=[
                ('objects', django.contrib.auth.models.UserManager()),
            ],
        ),
    ]


################################################################################
# File: accounts\migrations\__init__.py
################################################################################



################################################################################
# File: ai\__init__.py
################################################################################

default_app_config = "ai.apps.AiConfig"


################################################################################
# File: ai\admin.py
################################################################################

from django.contrib import admin

# Отдельных моделей БД для AI нет,
# но файл оставлен для совместимости с Django.


################################################################################
# File: ai\apps.py
################################################################################

from django.apps import AppConfig


class AiConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    # ВАЖНО: здесь должен быть реальный путь до пакета приложения
    # Папка называется "ai", лежит в корне проекта -> name = "ai"
    name = "ai"
    verbose_name = "AI и рекомендации ParkShare"


################################################################################
# File: ai\features.py
################################################################################

from __future__ import annotations

import pandas as pd

from parking.models import Booking


def bookings_dataframe() -> pd.DataFrame:
    """
    Собирает историю бронирований в DataFrame для обучения/аналитики.
    """
    qs = Booking.objects.filter(
        status__in=[
            Booking.Status.CONFIRMED,
            Booking.Status.ACTIVE,
            Booking.Status.COMPLETED,
        ]
    ).select_related("spot", "spot__lot")

    rows = []
    for b in qs:
        rows.append(
            {
                "booking_id": str(b.id),
                "spot_id": str(b.spot_id),
                "lot_id": str(b.spot.lot_id),
                "city": b.spot.lot.city,
                "start": b.start_at,
                "end": b.end_at,
                "duration_hours": (b.end_at - b.start_at).total_seconds() / 3600.0,
                "price": float(b.total_price),
                "dow": b.start_at.weekday(),
                "hour": b.start_at.hour,
            }
        )

    if not rows:
        return pd.DataFrame()

    df = pd.DataFrame(rows)
    df["is_weekend"] = df["dow"] >= 5
    return df


################################################################################
# File: ai\models.py
################################################################################



################################################################################
# File: ai\pricing.py
################################################################################

from __future__ import annotations

from pathlib import Path
from typing import Any, Dict, Optional

import joblib
import numpy as np
from django.conf import settings
from django.utils import timezone
from sklearn.ensemble import RandomForestRegressor

from core.utils import round_price
from parking.models import ParkingSpot
from .features import bookings_dataframe

MODEL_PATH = Path(getattr(settings, "BASE_DIR", ".")) / "ai_models" / "pricing_model.pkl"


def train_pricing_model(df=None) -> Optional[RandomForestRegressor]:
    """
    Обучает простую RandomForest-модель для оценки цены за час.
    """
    if df is None:
        df = bookings_dataframe()
    if df.empty or len(df) < 20:
        return None

    df = df.copy()
    df["price_per_hour"] = df["price"] / df["duration_hours"].clip(lower=0.5)
    X = df[["hour", "dow", "is_weekend"]].values
    y = df["price_per_hour"].values

    model = RandomForestRegressor(
        n_estimators=50,
        random_state=42,
        n_jobs=-1,
    )
    model.fit(X, y)

    MODEL_PATH.parent.mkdir(parents=True, exist_ok=True)
    joblib.dump(model, MODEL_PATH)
    return model


def load_pricing_model() -> Optional[RandomForestRegressor]:
    if not MODEL_PATH.exists():
        return None
    try:
        model: RandomForestRegressor = joblib.load(MODEL_PATH)
        return model
    except Exception:
        return None


def recommend_price_for_spot(spot: ParkingSpot) -> Optional[Dict[str, Any]]:
    """
    Возвращает диапазон рекомендованных цен для владельца места.
    Учитывает:
    - базовую цену;
    - загрузку места за 7 дней (occupancy_7d);
    - (по возможности) предсказание ML‑модели.
    """
    base_price = float(spot.hourly_price or 0.0)
    if base_price <= 0:
        return None

    now = timezone.now()
    features = np.array([[now.hour, now.weekday(), 1 if now.weekday() >= 5 else 0]])

    model = load_pricing_model()
    predicted = None
    if model is not None:
        try:
            predicted_value = float(model.predict(features)[0])
            if predicted_value > 0:
                predicted = predicted_value
        except Exception:
            predicted = None

    occupancy = float(getattr(spot, "occupancy_7d", 0.0) or 0.0)
    factor = 1.0
    reason_parts = []

    if occupancy > 0.8:
        factor += 0.15
        reason_parts.append("место часто занято (высокая загрузка)")
    elif occupancy < 0.3:
        factor -= 0.1
        reason_parts.append("место простаивает (низкая загрузка)")

    if predicted is not None:
        ai_price = round_price(predicted, step=5.0)
        reason_parts.append("ML‑модель учитывает исторические цены по району")
    else:
        ai_price = base_price

    recommended = round_price(ai_price * factor, step=5.0)
    min_price = round_price(recommended * 0.9, step=5.0)
    max_price = round_price(recommended * 1.1, step=5.0)

    if not reason_parts:
        reason_parts.append("используется базовая ставка и средняя загрузка")

    reason = "На основе: " + "; ".join(reason_parts) + "."
    return {
        "base_price": base_price,
        "recommended_price": recommended,
        "min_price": min_price,
        "max_price": max_price,
        "reason": reason,
    }


################################################################################
# File: ai\serializers.py
################################################################################



################################################################################
# File: ai\tasks.py
################################################################################

from __future__ import annotations

from datetime import timedelta

from celery import shared_task
from django.utils import timezone

from parking.models import Booking, ParkingLot, ParkingSpot
from .features import bookings_dataframe
from .pricing import train_pricing_model


@shared_task
def update_models() -> None:
    """
    Периодически обучает модель цен и обновляет метрики загруженности.

    Делает три вещи:
    1) обучает/переобучает ML‑модель ценообразования;
    2) считает occupancy_7d для активных мест;
    3) считает stress_index для парковок (средняя загрузка мест).
    """
    df = bookings_dataframe()
    train_pricing_model(df)

    now = timezone.now()
    window_start = now - timedelta(days=7)

    # 1–2. Обновляем occupancy_7d для мест
    active_spots = ParkingSpot.objects.filter(
        status=ParkingSpot.SpotStatus.ACTIVE,
        lot__is_active=True,
        lot__is_approved=True,
    ).select_related("lot")

    total_period_hours = 24 * 7

    for spot in active_spots:
        qs = Booking.objects.filter(
            spot=spot,
            start_at__lt=now,
            end_at__gt=window_start,
            status__in=[
                Booking.Status.CONFIRMED,
                Booking.Status.ACTIVE,
                Booking.Status.COMPLETED,
            ],
        )

        booked_hours = 0.0
        for b in qs:
            start = max(b.start_at, window_start)
            end = min(b.end_at, now)
            delta_h = max((end - start).total_seconds() / 3600.0, 0.0)
            booked_hours += delta_h

        occupancy = booked_hours / float(total_period_hours)
        spot.occupancy_7d = max(0.0, min(occupancy, 1.0))
        spot.save(update_fields=["occupancy_7d"])

    # 3. Индекс загруженности по объектам парковки
    lots = ParkingLot.objects.filter(is_active=True, is_approved=True)
    for lot in lots:
        spots = lot.spots.all()
        if not spots:
            lot.stress_index = 0.0
            lot.save(update_fields=["stress_index"])
            continue
        values = [max(0.0, min(s.occupancy_7d, 1.0)) for s in spots]
        lot.stress_index = sum(values) / len(values)
        lot.save(update_fields=["stress_index"])


################################################################################
# File: ai\views.py
################################################################################

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status


class RecommendationsAPIView(APIView):
    """
    Возвращает заглушку AI-рекомендаций.
    """
    def get(self, request, *args, **kwargs):
        return Response(
            {
                "recommendations": [],
                "message": "AI-рекомендации пока не реализованы",
            },
            status=status.HTTP_200_OK,
        )


class StressIndexAPIView(APIView):
    """
    Заглушка индекса загруженности парковок.
    """
    def get(self, request, *args, **kwargs):
        return Response(
            {
                "stress_index": 0,
                "details": "AI-индекс загруженности пока не реализован",
            },
            status=status.HTTP_200_OK,
        )


class DepartureAssistantAPIView(APIView):
    """
    Заглушка помощника по времени выезда.
    Например, в будущем тут можно будет учитывать пробки, время до парковки и т.п.
    """

    def post(self, request, *args, **kwargs):
        # На будущее: можно принимать в body:
        # - пункт назначения
        # - желаемое время прибытия
        # - примерное время на парковку/поиск места
        return Response(
            {
                "suggested_departure_time": None,
                "message": "AI-помощник по выезду пока не реализован",
            },
            status=status.HTTP_200_OK,
        )


################################################################################
# File: backend\manage.py
################################################################################

#!/usr/bin/env python
import os
import sys


def main() -> None:
    """Run administrative tasks."""
    os.environ.setdefault("DJANGO_SETTINGS_MODULE", "backend.settings.local")
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Не удалось импортировать Django. Убедитесь, что он установлен и "
            "доступен в вашем виртуальном окружении."
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == "__main__":
    main()


################################################################################
# File: backend\backend\__init__.py
################################################################################

from .config.celery import app as celery_app

__all__ = ("celery_app",)


################################################################################
# File: backend\backend\config\__init__.py
################################################################################

# Пустой, но важно наличия для импорта настроек и celery.


################################################################################
# File: backend\backend\config\asgi.py
################################################################################

import os

from django.core.asgi import get_asgi_application

os.environ.setdefault("DJANGO_SETTINGS_MODULE", "backend.settings.local")

application = get_asgi_application()


################################################################################
# File: backend\backend\config\celery.py
################################################################################

import os

from celery import Celery

os.environ.setdefault("DJANGO_SETTINGS_MODULE", "backend.settings.local")

app = Celery("backend")

# Читаем конфиг из Django settings, все переменные CELERY_*
app.config_from_object("django.conf:settings", namespace="CELERY")

# Авто‑обнаружение tasks.py во всех приложениях
app.autodiscover_tasks()


@app.task(bind=True)
def debug_task(self):
    print(f"Debug task: Request: {self.request!r}")


################################################################################
# File: backend\backend\config\urls.py
################################################################################

from django.conf import settings
from django.conf.urls.static import static
from django.contrib import admin
from django.contrib.staticfiles import finders
from django.http import Http404, HttpResponse
from django.urls import include, path
from django.views.decorators.cache import never_cache
from django.views.generic import TemplateView
from drf_spectacular.views import (
    SpectacularAPIView,
    SpectacularRedocView,
    SpectacularSwaggerView,
)
from rest_framework import routers

from accounts import views as accounts_api
from ai import views as ai_api
from parking import views as parking_views
from payments import views as payments_api
from vehicles import views as vehicles_api

router = routers.DefaultRouter()

# Accounts / пользователи (только API)
router.register(r"accounts/users", accounts_api.UserViewSet, basename="user")

# Vehicles
router.register(r"vehicles", vehicles_api.VehicleViewSet, basename="vehicle")

# Parking
router.register(r"parking/lots", parking_views.ParkingLotViewSet, basename="parking-lot")
router.register(r"parking/spots", parking_views.ParkingSpotViewSet, basename="parking-spot")
router.register(r"parking/bookings", parking_views.BookingViewSet, basename="booking")
router.register(r"parking/waitlist", parking_views.WaitlistViewSet, basename="waitlist")
router.register(r"parking/complaints", parking_views.ComplaintViewSet, basename="complaint")

# Payments
router.register(r"payments", payments_api.PaymentViewSet, basename="payment")


@never_cache
def service_worker(request):
    """
    Отдаём service-worker.js с корня домена, но физически он лежит в static/.
    """
    path = finders.find("service-worker.js")
    if not path:
        raise Http404("Service worker not found")
    with open(path, "rb") as f:
        content = f.read()
    return HttpResponse(content, content_type="application/javascript")


@never_cache
def manifest(request):
    """
    Отдаём manifest.webmanifest с правильным content-type.
    """
    path = finders.find("manifest.webmanifest")
    if not path:
        raise Http404("Manifest not found")
    with open(path, "rb") as f:
        content = f.read()
    return HttpResponse(content, content_type="application/manifest+json")


urlpatterns = [
    path("admin/", admin.site.urls),

    # PWA файлы
    path("service-worker.js", service_worker, name="service_worker"),
    path("manifest.webmanifest", manifest, name="manifest"),

    # Web‑страницы
    path("", parking_views.LandingPageView.as_view(), name="landing"),
    path("личный-кабинет/", parking_views.UserDashboardView.as_view(), name="user_dashboard"),
    path("кабинет-владельца/", parking_views.OwnerDashboardView.as_view(), name="owner_dashboard"),
    path("offline/", TemplateView.as_view(template_name="offline.html"), name="offline"),

    # Auth страницы (регистрация/логин/сброс пароля)
    path("accounts/", include("accounts.urls")),

    # API (DRF router)
    path("api/", include(router.urls)),

    # OpenAPI / документация
    path("api/schema/", SpectacularAPIView.as_view(), name="api-schema"),
    path(
        "api/docs/",
        SpectacularSwaggerView.as_view(url_name="api-schema"),
        name="api-docs",
    ),
    path(
        "api/docs/redoc/",
        SpectacularRedocView.as_view(url_name="api-schema"),
        name="api-docs-redoc",
    ),

    # AI API
    path("api/ai/recommendations/", ai_api.RecommendationsAPIView.as_view(), name="ai_recommendations"),
    path("api/ai/stress-index/", ai_api.StressIndexAPIView.as_view(), name="ai_stress_index"),
    path("api/ai/departure-assistant/", ai_api.DepartureAssistantAPIView.as_view(), name="ai_departure_assistant"),

    # Payments webhooks
    path("payments/webhook/yookassa/", payments_api.YooKassaWebhookView.as_view(), name="yookassa_webhook"),

    # DRF browsable API login/logout
    path("api-auth/", include("rest_framework.urls")),
]

if settings.DEBUG:
    urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)
    urlpatterns += static(settings.STATIC_URL, document_root=settings.STATIC_ROOT)


################################################################################
# File: backend\backend\config\wsgi.py
################################################################################

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault("DJANGO_SETTINGS_MODULE", "backend.settings.local")

application = get_wsgi_application()


################################################################################
# File: backend\backend\settings\__init__.py
################################################################################

"""
Пакет настроек Django.

По умолчанию используются настройки для локальной разработки
(`backend.settings.local`).

Для продакшена задайте переменную окружения:

    DJANGO_SETTINGS_MODULE=backend.settings.production
"""

from .local import *  # noqa: F401,F403


################################################################################
# File: backend\backend\settings\base.py
################################################################################

import os
from pathlib import Path
from typing import List

import environ

# ---------------------------------------------------------------------------
# Пути
# ---------------------------------------------------------------------------

# BASE_DIR — корень репозитория: C:\Users\Sultan\Downloads\parkshare_ru_part1
BASE_DIR = Path(__file__).resolve().parents[3]

# Тут главная правка: больше не уходим на уровень выше
PROJECT_ROOT = BASE_DIR  # C:\Users\Sultan\Downloads\parkshare_ru_part1


# ---------------------------------------------------------------------------
# Окружение
# ---------------------------------------------------------------------------

env = environ.Env(
    DEBUG=(bool, False),
)

env_file = PROJECT_ROOT / ".env"
if env_file.exists():
    environ.Env.read_env(str(env_file))

DEBUG: bool = env.bool("DEBUG", default=False)
SECRET_KEY: str = env("SECRET_KEY", default="unsafe-secret-key-change-me")

ALLOWED_HOSTS: List[str] = env.list("ALLOWED_HOSTS", default=["localhost", "127.0.0.1"])

# ---------------------------------------------------------------------------
# Приложения
# ---------------------------------------------------------------------------

INSTALLED_APPS = [
    # Django
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",

    # Сторонние
    "rest_framework",
    "corsheaders",
    "django_cryptography",
    "drf_spectacular",

    # Проектные
    "accounts",
    "vehicles",
    "parking",
    "payments",
    "ai",
    "core",
]

MIDDLEWARE = [
    "corsheaders.middleware.CorsMiddleware",
    "django.middleware.security.SecurityMiddleware",
    "django.middleware.gzip.GZipMiddleware",
    "django.contrib.sessions.middleware.SessionMiddleware",
    "django.middleware.common.CommonMiddleware",
    "django.middleware.csrf.CsrfViewMiddleware",
    "django.contrib.auth.middleware.AuthenticationMiddleware",
    "django.contrib.messages.middleware.MessageMiddleware",
    "django.middleware.clickjacking.XFrameOptionsMiddleware",
]

ROOT_URLCONF = "backend.config.urls"

TEMPLATES = [
    {
        "BACKEND": "django.template.backends.django.DjangoTemplates",
        "DIRS": [BASE_DIR / "templates"],
        "APP_DIRS": True,
        "OPTIONS": {
            "context_processors": [
                "django.template.context_processors.debug",
                "django.template.context_processors.request",
                "django.contrib.auth.context_processors.auth",
                "django.contrib.messages.context_processors.messages",
            ],
        },
    },
]

WSGI_APPLICATION = "backend.config.wsgi.application"
ASGI_APPLICATION = "backend.config.asgi.application"

# ---------------------------------------------------------------------------
# Базы данных
# ---------------------------------------------------------------------------

DATABASES = {
    "default": env.db(
        "DATABASE_URL", default=f"sqlite:///{BASE_DIR / 'db.sqlite3'}"
    )
}

# Если используем PostgreSQL — переключаемся на PostGIS
if DATABASES["default"]["ENGINE"] == "django.db.backends.postgresql":
    DATABASES["default"]["ENGINE"] = "django.contrib.gis.db.backends.postgis"

# ---------------------------------------------------------------------------
# Пользователь / аутентификация
# ---------------------------------------------------------------------------

AUTH_USER_MODEL = "accounts.User"

AUTH_PASSWORD_VALIDATORS = [
    {
        "NAME": "django.contrib.auth.password_validation.UserAttributeSimilarityValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.MinimumLengthValidator",
        "OPTIONS": {"min_length": 8},
    },
    {
        "NAME": "django.contrib.auth.password_validation.CommonPasswordValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.NumericPasswordValidator",
    },
]

# ---------------------------------------------------------------------------
# Локализация
# ---------------------------------------------------------------------------

LANGUAGE_CODE = env("LANGUAGE_CODE", default="ru-ru")
TIME_ZONE = env("TIME_ZONE", default="Europe/Moscow")
USE_I18N = True
USE_L10N = True
USE_TZ = True

# ---------------------------------------------------------------------------
# Статика / медиа
# ---------------------------------------------------------------------------

STATIC_URL = "/static/"
STATIC_ROOT = BASE_DIR / "staticfiles"
STATICFILES_DIRS = [
    BASE_DIR / "static",
]

MEDIA_URL = "/media/"
MEDIA_ROOT = BASE_DIR / "media"

# ---------------------------------------------------------------------------
# PWA
# ---------------------------------------------------------------------------

PWA_APP_NAME = "ParkShare RU"
PWA_APP_SHORT_NAME = "ParkShare"
PWA_THEME_COLOR = "#0d6efd"
PWA_BACKGROUND_COLOR = "#050816"

# ---------------------------------------------------------------------------
# DRF / OpenAPI
# ---------------------------------------------------------------------------

REST_FRAMEWORK = {
    "DEFAULT_AUTHENTICATION_CLASSES": [
        "rest_framework.authentication.SessionAuthentication",
    ],
    "DEFAULT_PERMISSION_CLASSES": [
        "rest_framework.permissions.IsAuthenticatedOrReadOnly",
    ],
    "DEFAULT_PAGINATION_CLASS": "core.pagination.DefaultPageNumberPagination",
    "PAGE_SIZE": 20,
    "DEFAULT_SCHEMA_CLASS": "drf_spectacular.openapi.AutoSchema",
}

SPECTACULAR_SETTINGS = {
    "TITLE": "ParkShare RU API",
    "DESCRIPTION": "API сервиса бронирования парковочных мест ParkShare RU.",
    "VERSION": "1.0.0",
    "SERVE_INCLUDE_SCHEMA": False,
}

# ---------------------------------------------------------------------------
# CORS
# ---------------------------------------------------------------------------

CORS_ALLOWED_ORIGINS = env.list("CORS_ALLOWED_ORIGINS", default=[])
CORS_ALLOW_CREDENTIALS = True

# ---------------------------------------------------------------------------
# Redis / Celery
# ---------------------------------------------------------------------------

REDIS_URL = env("REDIS_URL", default="redis://redis:6379/0")

CELERY_BROKER_URL = env("CELERY_BROKER_URL", default=REDIS_URL)
CELERY_RESULT_BACKEND = env("CELERY_RESULT_BACKEND", default=REDIS_URL)
CELERY_ACCEPT_CONTENT = ["json"]
CELERY_TASK_SERIALIZER = "json"
CELERY_RESULT_SERIALIZER = "json"
CELERY_TIMEZONE = TIME_ZONE

CELERY_BEAT_SCHEDULE = {
    "expire_unpaid_bookings": {
        "task": "parking.tasks.expire_unpaid_bookings",
        "schedule": 60 * 10,  # каждые 10 минут
    },
    "update_ai_models": {
        "task": "ai.tasks.update_models",
        "schedule": 60 * 60,  # раз в час
    },
    "check_stale_payments": {
        "task": "payments.tasks.check_stale_payments",
        "schedule": 60 * 15,  # каждые 15 минут
    },
}

# ---------------------------------------------------------------------------
# Логи
# ---------------------------------------------------------------------------

LOGGING = {
    "version": 1,
    "disable_existing_loggers": False,
    "formatters": {
        "verbose": {
            "format": "[{asctime}] {levelname} {name} {message}",
            "style": "{",
        },
        "simple": {
            "format": "{levelname} {message}",
            "style": "{",
        },
    },
    "handlers": {
        "console": {
            "class": "logging.StreamHandler",
            "formatter": "verbose",
        },
    },
    "loggers": {
        "django": {
            "handlers": ["console"],
            "level": "INFO",
        },
        "parkshare": {
            "handlers": ["console"],
            "level": "INFO",
        },
    },
}

# ---------------------------------------------------------------------------
# Email
# ---------------------------------------------------------------------------

EMAIL_BACKEND = env(
    "EMAIL_BACKEND",
    default="django.core.mail.backends.console.EmailBackend",
)
DEFAULT_FROM_EMAIL = env(
    "DEFAULT_FROM_EMAIL",
    default="ParkShare RU <noreply@example.com>",
)
SERVER_EMAIL = env("SERVER_EMAIL", default=DEFAULT_FROM_EMAIL)

# ---------------------------------------------------------------------------
# Безопасность (базовый уровень, детали переопределяются в production.py)
# ---------------------------------------------------------------------------

SECURE_SSL_REDIRECT = env.bool("SECURE_SSL_REDIRECT", default=False)
SESSION_COOKIE_SECURE = env.bool("SESSION_COOKIE_SECURE", default=False)
CSRF_COOKIE_SECURE = env.bool("CSRF_COOKIE_SECURE", default=False)
X_FRAME_OPTIONS = "DENY"

# ---------------------------------------------------------------------------
# django-cryptography
# ---------------------------------------------------------------------------

DJANGO_CRYPTography_KEY = SECRET_KEY

# ---------------------------------------------------------------------------
# Бизнес-настройки
# ---------------------------------------------------------------------------

VEHICLE_PLATE_SALT = env("VEHICLE_PLATE_SALT", default="change_me_vehicle_salt")

YOOKASSA_SHOP_ID = env("YOOKASSA_SHOP_ID", default="")
YOOKASSA_SECRET_KEY = env("YOOKASSA_SECRET_KEY", default="")
YOOKASSA_RETURN_URL = env("YOOKASSA_RETURN_URL", default="")
YOOKASSA_WEBHOOK_SECRET = env("YOOKASSA_WEBHOOK_SECRET", default="")

SERVICE_COMMISSION_PERCENT = env.int("SERVICE_COMMISSION_PERCENT", default=10)

# ---------------------------------------------------------------------------
# Кэш по умолчанию — in-memory (в продакшене можно переключить на Redis)
# ---------------------------------------------------------------------------

CACHES = {
    "default": {
        "BACKEND": "django.core.cache.backends.locmem.LocMemCache",
        "LOCATION": "parkshare_cache",
    }
}


################################################################################
# File: backend\backend\settings\local.py
################################################################################

from .base import *  # noqa: F401,F403

# Локальная разработка

DEBUG = env.bool("DEBUG", default=True)
ALLOWED_HOSTS = env.list("ALLOWED_HOSTS", default=["127.0.0.1", "localhost"])

INTERNAL_IPS = ["127.0.0.1"]

SECURE_SSL_REDIRECT = False
SESSION_COOKIE_SECURE = False
CSRF_COOKIE_SECURE = False


################################################################################
# File: backend\backend\settings\production.py
################################################################################

from django.core.exceptions import ImproperlyConfigured

from .base import *  # noqa: F401,F403

# Продакшен-настройки

DEBUG = False

ALLOWED_HOSTS = env.list("ALLOWED_HOSTS", default=[])
if not ALLOWED_HOSTS:
    raise ImproperlyConfigured(
        "В продакшене ALLOWED_HOSTS не должен быть пустым. "
        "Задайте ALLOWED_HOSTS в .env"
    )

SECURE_SSL_REDIRECT = env.bool("SECURE_SSL_REDIRECT", default=True)
SESSION_COOKIE_SECURE = env.bool("SESSION_COOKIE_SECURE", default=True)
CSRF_COOKIE_SECURE = env.bool("CSRF_COOKIE_SECURE", default=True)

SECURE_HSTS_SECONDS = env.int("SECURE_HSTS_SECONDS", default=60 * 60 * 24)
SECURE_HSTS_INCLUDE_SUBDOMAINS = True
SECURE_HSTS_PRELOAD = True


################################################################################
# File: backend\tests\__init__.py
################################################################################

# Пакет с базовыми тестами проекта ParkShare RU.


################################################################################
# File: backend\tests\test_auth_api.py
################################################################################

from django.test import TestCase
from rest_framework.test import APIClient


class AuthApiTests(TestCase):
    def setUp(self) -> None:
        self.client = APIClient()
        self.password = "StrongPass123"

    def test_register_and_login_by_username_email_and_phone(self):
        # Регистрация
        resp = self.client.post(
            "/api/accounts/users/register/",
            {
                "username": "demo",
                "password": self.password,
                "email": "demo@example.com",
                "phone": "+7 (999) 123-45-67",
            },
            format="json",
        )
        self.assertEqual(resp.status_code, 201)
        self.client.logout()

        # Логин по логину
        resp = self.client.post(
            "/api/accounts/users/login/",
            {"identifier": "demo", "password": self.password},
            format="json",
        )
        self.assertEqual(resp.status_code, 200)
        self.assertEqual(resp.data["username"], "demo")
        self.client.logout()

        # Логин по email
        resp = self.client.post(
            "/api/accounts/users/login/",
            {"identifier": "demo@example.com", "password": self.password},
            format="json",
        )
        self.assertEqual(resp.status_code, 200)
        self.client.logout()

        # Логин по телефону (в любом удобном формате)
        resp = self.client.post(
            "/api/accounts/users/login/",
            {"identifier": "+7 999 123-45-67", "password": self.password},
            format="json",
        )
        self.assertEqual(resp.status_code, 200)


################################################################################
# File: backend\tests\test_booking_model.py
################################################################################

from datetime import timedelta
from decimal import Decimal

from django.test import TestCase
from django.utils import timezone

from accounts.models import User
from parking.models import Booking, ParkingLot, ParkingSpot


class BookingModelTests(TestCase):
    def setUp(self) -> None:
        self.owner = User.objects.create_user(
            username="owner",
            password="StrongPass123",
            role=User.Role.OWNER,
        )
        self.driver = User.objects.create_user(
            username="driver",
            password="StrongPass123",
            role=User.Role.DRIVER,
        )

        self.lot = ParkingLot.objects.create(
            owner=self.owner,
            name="Test Lot",
            city="Test City",
            address="Test street, 1",
        )
        self.spot = ParkingSpot.objects.create(
            lot=self.lot,
            name="A1",
            hourly_price=Decimal("100.00"),
        )

    def test_calculate_price_hourly_with_commission(self):
        now = timezone.now()
        booking = Booking(
            user=self.driver,
            spot=self.spot,
            booking_type=Booking.BookingType.HOURLY,
            start_at=now,
            end_at=now + timedelta(hours=1, minutes=30),
            total_price=Decimal("0.00"),
            currency="RUB",
        )
        total = booking.calculate_price()
        # 2 часа * 100 ₽ + 10% комиссии = 220
        self.assertEqual(total, Decimal("220.00"))

    def test_is_spot_available(self):
        now = timezone.now()
        existing = Booking.objects.create(
            user=self.driver,
            spot=self.spot,
            booking_type=Booking.BookingType.HOURLY,
            start_at=now,
            end_at=now + timedelta(hours=2),
            status=Booking.Status.CONFIRMED,
            total_price=Decimal("200.00"),
            currency="RUB",
        )

        # Пересекающийся интервал — недоступен
        self.assertFalse(
            Booking.is_spot_available(
                self.spot,
                now + timedelta(minutes=30),
                now + timedelta(hours=3),
            )
        )

        # Непересекающийся интервал — доступен
        self.assertTrue(
            Booking.is_spot_available(
                self.spot,
                existing.end_at + timedelta(minutes=1),
                existing.end_at + timedelta(hours=1),
            )
        )


################################################################################
# File: core\__init__.py
################################################################################



################################################################################
# File: core\admin.py
################################################################################



################################################################################
# File: core\apps.py
################################################################################

# core/apps.py

from django.apps import AppConfig


class CoreConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "core"
    verbose_name = "Ядро ParkShare"


################################################################################
# File: core\models.py
################################################################################

# backend/core/models.py
import uuid

from django.db import models
from django.utils.translation import gettext_lazy as _


class TimeStampedModel(models.Model):
    """
    Абстрактная модель с полями created_at/updated_at.

    Используется для единообразного аудита времени создания и обновления
    записей в базовых моделях (парковки, бронирования, платежи и т.п.).
    """

    created_at = models.DateTimeField(_("Дата создания"), auto_now_add=True)
    updated_at = models.DateTimeField(_("Дата обновления"), auto_now=True)

    class Meta:
        abstract = True


class UUIDModel(models.Model):
    """Абстрактная модель с UUID в качестве первичного ключа."""

    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)

    class Meta:
        abstract = True


class TimeStampedUUIDModel(TimeStampedModel, UUIDModel):
    """Комбо UUID + таймстемпы."""

    class Meta:
        abstract = True


################################################################################
# File: core\pagination.py
################################################################################

# core/pagination.py

from django.conf import settings
from rest_framework.pagination import PageNumberPagination


class DefaultPageNumberPagination(PageNumberPagination):
    """
    Базовый пагинатор для API.
    Размер страницы берётся из настроек DRF (PAGE_SIZE), с возможностью
    переопределения через query-параметр ?page_size=.
    """

    page_size = settings.REST_FRAMEWORK.get("PAGE_SIZE", 20)
    page_size_query_param = "page_size"
    max_page_size = 100


################################################################################
# File: core\permissions.py
################################################################################

# core/permissions.py

from typing import Any

from django.contrib.auth import get_user_model
from rest_framework.permissions import BasePermission, SAFE_METHODS

User = get_user_model()


def _is_admin(user: User) -> bool:
    """
    Утилита: определение админа по суперпользователю или роли.
    """
    if not user.is_authenticated:
        return False

    role_cls = getattr(User, "Role", None)
    admin_value = None
    if role_cls is not None:
        admin_value = getattr(role_cls, "ADMIN", None)

    if admin_value is not None:
        return bool(user.is_superuser or getattr(user, "role", "") == admin_value)

    return bool(user.is_superuser or getattr(user, "is_staff", False))


class IsAdminOrReadOnly(BasePermission):
    """
    Разрешает только администраторам изменять данные, остальным — только чтение.
    """

    def has_permission(self, request, view) -> bool:
        if request.method in SAFE_METHODS:
            return True
        user: User = request.user
        return _is_admin(user)


class IsSelfOrAdmin(BasePermission):
    """
    Доступ к объекту пользователя: либо сам пользователь, либо админ.
    """

    def has_object_permission(self, request, view, obj: Any) -> bool:
        user: User = request.user
        if not user.is_authenticated:
            return False
        if _is_admin(user):
            return True
        return getattr(obj, "pk", None) == getattr(user, "pk", None)


class IsOwnerObject(BasePermission):
    """
    Доступ к объектам, у которых есть атрибут owner: только владелец или админ.
    """

    def has_object_permission(self, request, view, obj: Any) -> bool:
        user: User = request.user
        if not user.is_authenticated:
            return False
        if _is_admin(user):
            return True
        owner = getattr(obj, "owner", None)
        return owner == user


################################################################################
# File: core\utils.py
################################################################################

# backend/core/utils.py

import hashlib
import math
from decimal import Decimal, ROUND_HALF_UP
from typing import Optional

from django.conf import settings


def hash_plate_digits(plate: str) -> str:
    """
    Хэширует только цифры госномера с солью (SHA‑256).
    Буквы и пробелы игнорируются.
    В БД мы сохраняем только этот хэш.
    """
    if not plate:
        return ""
    digits = "".join(ch for ch in plate if ch.isdigit())
    salted = f"{settings.VEHICLE_PLATE_SALT}:{digits}"
    return hashlib.sha256(salted.encode("utf-8")).hexdigest()


def mask_plate_for_display(plate: str) -> str:
    """
    Возвращает маску номера для отображения (если вдруг нужно выводить).
    Фактический номер мы нигде не храним, поэтому функция может применяться
    только к введённому пользователем значению до хэширования.
    """
    digits = "".join(ch for ch in plate if ch.isdigit())
    if not digits:
        return ""
    if len(digits) <= 2:
        return "*" * len(digits)
    return "*" * (len(digits) - 2) + digits[-2:]


def normalize_phone(phone: Optional[str]) -> str:
    """
    Нормализация телефона:

    - убираем все символы кроме цифр и '+';
    - для РФ приводим к формату +7XXXXXXXXXX, если возможно;
    - для остальных стран просто добавляем '+' перед цифрами.
    """
    if not phone:
        return ""
    raw = phone.strip()

    # Оставляем плюс только в начале
    plus = "+" if raw.startswith("+") else ""
    digits = "".join(ch for ch in raw if ch.isdigit())
    if not digits:
        return ""

    # РФ: 10 или 11 цифр, начинающихся с 8/7
    if len(digits) == 11 and digits.startswith("8"):
        digits = "7" + digits[1:]
    elif len(digits) == 10:
        digits = "7" + digits

    if plus or digits.startswith("7"):
        return "+" + digits
    return "+" + digits  # простой фолбэк


def haversine_distance_km(
    lat1: float, lon1: float, lat2: float, lon2: float
) -> float:
    """
    Расстояние между двумя точками на сфере Земли (км).

    Используем для поиска парковок «рядом» без обязательной привязки
    к PostGIS (работает и на SQLite).
    """
    try:
        lat1_f = float(lat1)
        lon1_f = float(lon1)
        lat2_f = float(lat2)
        lon2_f = float(lon2)
    except (TypeError, ValueError):
        return 0.0

    radius = 6371.0  # км

    d_lat = math.radians(lat2_f - lat1_f)
    d_lon = math.radians(lon2_f - lon1_f)
    r_lat1 = math.radians(lat1_f)
    r_lat2 = math.radians(lat2_f)

    a = (
        math.sin(d_lat / 2) ** 2
        + math.cos(r_lat1) * math.cos(r_lat2) * math.sin(d_lon / 2) ** 2
    )
    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))
    return radius * c


def parse_float(value: Optional[str]) -> Optional[float]:
    """
    Аккуратно парсит строку в float, возвращая None при ошибке.
    Удобно для работы с query‑параметрами API.
    """
    if value is None:
        return None
    try:
        return float(value)
    except (TypeError, ValueError):
        return None


def round_price(value: float | Decimal, step: float = 10.0) -> float:
    """
    Округляет цену к ближайшему шагу (step), по умолчанию — 10 ₽.

    Используется в AI-модуле ценообразования.
    """
    if step <= 0:
        return float(Decimal(str(value)).quantize(Decimal("0.01")))

    v = Decimal(str(value))
    step_dec = Decimal(str(step))
    scaled = (v / step_dec).quantize(Decimal("1"), rounding=ROUND_HALF_UP)
    result = scaled * step_dec
    return float(result)


################################################################################
# File: nginx\nginx.conf
################################################################################

user  nginx;
worker_processes  auto;

error_log  /var/log/nginx/error.log warn;
pid        /var/run/nginx.pid;

events {
    worker_connections  1024;
}

http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';

    access_log  /var/log/nginx/access.log  main;

    sendfile        on;
    keepalive_timeout  65;

    upstream django {
        server web:8000;
    }

    server {
        listen 80;
        server_name _;

        # Статика и медиа
        location /static/ {
            alias /static/;
        }

        location /media/ {
            alias /media/;
        }

        # Проксирование всех остальных запросов к Django
        location / {
            proxy_pass http://django;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }
    }
}


################################################################################
# File: parking\__init__.py
################################################################################

# backend/parking/__init__.py

default_app_config = "parking.apps.ParkingConfig"


################################################################################
# File: parking\admin.py
################################################################################

# backend/parking/admin.py

from django.contrib import admin

from .models import Booking, Complaint, ParkingLot, ParkingSpot, WaitlistEntry


@admin.register(ParkingLot)
class ParkingLotAdmin(admin.ModelAdmin):
    list_display = ("name", "city", "owner", "parking_type", "is_active", "is_approved")
    list_filter = ("city", "parking_type", "is_active", "is_approved")
    search_fields = ("name", "city", "address", "owner__username")
    autocomplete_fields = ("owner",)


@admin.register(ParkingSpot)
class ParkingSpotAdmin(admin.ModelAdmin):
    list_display = (
        "name",
        "lot",
        "vehicle_type",
        "is_covered",
        "has_ev_charging",
        "status",
        "hourly_price",
    )
    list_filter = (
        "vehicle_type",
        "is_covered",
        "has_ev_charging",
        "status",
        "lot__city",
    )
    search_fields = ("name", "lot__name", "lot__city")
    autocomplete_fields = ("lot",)


@admin.register(Booking)
class BookingAdmin(admin.ModelAdmin):
    list_display = (
        "id",
        "spot",
        "user",
        "booking_type",
        "status",
        "start_at",
        "end_at",
        "total_price",
        "is_paid",
    )
    list_filter = ("booking_type", "status", "start_at", "spot__lot__city")
    search_fields = ("spot__name", "spot__lot__name", "user__username")
    autocomplete_fields = ("spot", "user", "vehicle")


@admin.register(WaitlistEntry)
class WaitlistEntryAdmin(admin.ModelAdmin):
    list_display = ("id", "user", "spot", "status", "auto_book", "created_at")
    list_filter = ("status", "auto_book", "created_at")
    search_fields = ("user__username", "spot__name")
    autocomplete_fields = ("user", "spot")


@admin.register(Complaint)
class ComplaintAdmin(admin.ModelAdmin):
    list_display = ("id", "author", "category", "status", "created_at")
    list_filter = ("category", "status", "created_at")
    search_fields = ("author__username", "description")
    autocomplete_fields = ("author", "booking", "spot")


################################################################################
# File: parking\apps.py
################################################################################

# backend/parking/apps.py

from django.apps import AppConfig


class ParkingConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "parking"
    verbose_name = "Парковки и бронирования"


################################################################################
# File: parking\models.py
################################################################################

# backend/parking/models.py

from __future__ import annotations

from datetime import timedelta
from decimal import Decimal, ROUND_UP
from typing import Optional

from django.conf import settings
from django.db import models
from django.utils import timezone
from django.utils.translation import gettext_lazy as _

from core.models import TimeStampedModel


# PointField с fallback для SQLite: храним JSON {"lat": ..., "lng": ...}
_db_settings = getattr(settings, "DATABASES", {})
_default_db = _db_settings.get("default") or {}
_default_engine = _default_db.get("ENGINE", "")


if _default_engine.endswith("sqlite3"):
    class PointField(models.JSONField):  # type: ignore[misc]
        def __init__(self, *args, **kwargs):
            kwargs.pop("geography", None)
            super().__init__(*args, **kwargs)
else:  # PostGIS / другие GIS-бэкенды
    from django.contrib.gis.db.models import PointField  # type: ignore[assignment]


class ParkingLot(TimeStampedModel):
    """
    Объект парковки (двор, подземный паркинг, офисный паркинг и т.д.).
    """

    class ParkingType(models.TextChoices):
        YARD = "yard", "Дворовая парковка"
        UNDERGROUND = "underground", "Подземная парковка"
        MULTILEVEL = "multilevel", "Многоуровневая парковка"
        STREET = "street", "Уличная парковка"
        OFFICE = "office", "Офисная парковка"
        HOME = "home", "Домашнее место"

    owner = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name="parking_lots",
        verbose_name="Владелец",
    )
    name = models.CharField("Название", max_length=255)
    city = models.CharField("Город", max_length=100)
    address = models.CharField("Адрес", max_length=255)
    parking_type = models.CharField(
        "Тип парковки",
        max_length=32,
        choices=ParkingType.choices,
        default=ParkingType.YARD,
    )
    description = models.TextField("Описание", blank=True)

    location = PointField("Точка на карте", geography=True, null=True, blank=True)
    latitude = models.FloatField("Широта", null=True, blank=True)
    longitude = models.FloatField("Долгота", null=True, blank=True)

    is_active = models.BooleanField("Активен", default=True)
    is_approved = models.BooleanField(
        "Одобрен модерацией",
        default=False,
        help_text="Одобряется администратором перед публикацией.",
    )
    is_private = models.BooleanField(
        "Приватный",
        default=False,
        help_text="Если включено, объект виден только по прямым ссылкам/владельцу.",
    )

    stress_index = models.FloatField(
        "Индекс загруженности (0..1)",
        default=0.0,
        help_text=(
            "Средняя загруженность мест за последние 7 дней. "
            "Обновляется фоновыми задачами AI."
        ),
    )

    class Meta:
        verbose_name = "Объект парковки"
        verbose_name_plural = "Объекты парковки"
        ordering = ("name",)

    def __str__(self) -> str:
        return f"{self.name} ({self.city})"

    @property
    def owner_username(self) -> str:
        return getattr(self.owner, "username", "")

    def set_coordinates(self, lat: Optional[float], lng: Optional[float]) -> None:
        """
        Устанавливает координаты и PointField (если доступен GeoDjango).
        """
        self.latitude = lat
        self.longitude = lng
        if lat is None or lng is None:
            self.location = None
            return

        try:
            from django.contrib.gis.geos import Point  # type: ignore[import]
        except Exception:
            # SQLite/JSON fallback
            self.location = {"lat": lat, "lng": lng}
        else:
            self.location = Point(lng, lat)


class ParkingSpot(TimeStampedModel):
    """
    Конкретное парковочное место внутри ParkingLot.
    """

    class SpotStatus(models.TextChoices):
        ACTIVE = "active", "Активно"
        INACTIVE = "inactive", "Неактивно"

    class VehicleType(models.TextChoices):
        CAR = "car", "Легковой автомобиль"
        MOTO = "moto", "Мотоцикл"
        COMMERCIAL = "commercial", "Коммерческий транспорт"

    lot = models.ForeignKey(
        ParkingLot,
        on_delete=models.CASCADE,
        related_name="spots",
        verbose_name="Объект парковки",
    )
    name = models.CharField("Название/номер места", max_length=64)
    description = models.TextField("Описание", blank=True)

    vehicle_type = models.CharField(
        "Тип транспорта",
        max_length=16,
        choices=VehicleType.choices,
        default=VehicleType.CAR,
    )

    is_covered = models.BooleanField("Крытое место", default=False)
    has_ev_charging = models.BooleanField("Есть зарядка", default=False)
    is_24_7 = models.BooleanField("Круглосуточно", default=True)
    max_height_m = models.DecimalField(
        "Максимальная высота (м)",
        max_digits=4,
        decimal_places=2,
        null=True,
        blank=True,
    )

    hourly_price = models.DecimalField(
        "Цена за час, ₽", max_digits=8, decimal_places=2
    )
    nightly_price = models.DecimalField(
        "Цена за ночь, ₽", max_digits=8, decimal_places=2, null=True, blank=True
    )
    daily_price = models.DecimalField(
        "Цена за сутки, ₽", max_digits=8, decimal_places=2, null=True, blank=True
    )
    monthly_price = models.DecimalField(
        "Цена за месяц, ₽", max_digits=9, decimal_places=2, null=True, blank=True
    )

    allow_dynamic_pricing = models.BooleanField(
        "Динамическая цена (AI)",
        default=False,
        help_text="Если включено, тариф может корректироваться рекомендациями AI.",
    )

    status = models.CharField(
        "Статус",
        max_length=16,
        choices=SpotStatus.choices,
        default=SpotStatus.ACTIVE,
    )

    occupancy_7d = models.FloatField(
        "Загруженность за 7 дней (0..1)",
        default=0.0,
        help_text=(
            "Доля времени, когда место было занято за последние 7 дней. "
            "Обновляется фоновыми задачами AI."
        ),
    )

    class Meta:
        verbose_name = "Парковочное место"
        verbose_name_plural = "Парковочные места"
        ordering = ("lot__name", "name")

    def __str__(self) -> str:
        return f"{self.lot.name} — {self.name}"

    @property
    def owner(self):
        """
        Для IsOwnerObject из core.permissions: владелец места = владелец ParkingLot.
        """
        return self.lot.owner

    @property
    def city(self) -> str:
        return self.lot.city

    @property
    def is_active(self) -> bool:
        return (
            self.status == self.SpotStatus.ACTIVE
            and self.lot.is_active
            and self.lot.is_approved
        )


class Booking(TimeStampedModel):
    """
    Бронирование парковочного места.
    """

    class BookingType(models.TextChoices):
        HOURLY = "hourly", "Почасовая"
        DAILY = "daily", "Суточная"
        NIGHT = "night", "Ночная"
        WEEKLY = "weekly", "Недельная"
        MONTHLY = "monthly", "Месячная"

    class Status(models.TextChoices):
        PENDING = "pending", "Ожидает оплаты"
        CONFIRMED = "confirmed", "Подтверждена"
        ACTIVE = "active", "Активна"
        COMPLETED = "completed", "Завершена"
        CANCELLED = "cancelled", "Отменена"
        EXPIRED = "expired", "Истекла"

    user = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name="bookings",
        verbose_name="Пользователь",
    )
    spot = models.ForeignKey(
        ParkingSpot,
        on_delete=models.PROTECT,
        related_name="bookings",
        verbose_name="Парковочное место",
    )
    vehicle = models.ForeignKey(
        "vehicles.Vehicle",
        on_delete=models.SET_NULL,
        related_name="bookings",
        verbose_name="Транспорт",
        null=True,
        blank=True,
    )

    booking_type = models.CharField(
        "Тип бронирования",
        max_length=16,
        choices=BookingType.choices,
        default=BookingType.HOURLY,
    )

    start_at = models.DateTimeField("Начало брони")
    end_at = models.DateTimeField("Окончание брони")

    status = models.CharField(
        "Статус",
        max_length=16,
        choices=Status.choices,
        default=Status.PENDING,
    )
    total_price = models.DecimalField(
        "Итоговая стоимость, ₽", max_digits=10, decimal_places=2
    )
    currency = models.CharField("Валюта", max_length=8, default="RUB")
    is_paid = models.BooleanField("Оплачено", default=False)

    external_payment_id = models.CharField(
        "ID платежа провайдера",
        max_length=64,
        blank=True,
        help_text="Связка с платежом у провайдера (например, YooKassa payment_id).",
    )

    class Meta:
        verbose_name = "Бронирование"
        verbose_name_plural = "Бронирования"
        ordering = ("-start_at",)

    def __str__(self) -> str:
        return f"Бронь #{self.pk} — {self.spot} ({self.start_at} → {self.end_at})"

    @property
    def owner(self):
        """
        Для удобства — владелец места, по которому идёт бронь.
        """
        return self.spot.lot.owner

    @staticmethod
    def is_spot_available(
        spot: ParkingSpot,
        start_at,
        end_at,
        exclude_booking_id: Optional[int] = None,
    ) -> bool:
        """
        Проверка пересечения интервалов с существующими бронями.
        """
        qs = Booking.objects.filter(spot=spot).exclude(
            status__in=[Booking.Status.CANCELLED, Booking.Status.EXPIRED]
        )
        if exclude_booking_id:
            qs = qs.exclude(id=exclude_booking_id)
        # Пересечение интервалов: (start1 < end2) и (end1 > start2)
        overlap = qs.filter(start_at__lt=end_at, end_at__gt=start_at).exists()
        return not overlap

    def calculate_price(self) -> Decimal:
        """
        Простая модель расчёта цены на основе тарифов ParkingSpot и типа брони.
        """

        if not self.spot:
            return Decimal("0.00")

        delta = self.end_at - self.start_at
        total_hours = Decimal(delta.total_seconds()) / Decimal(3600)
        total_days = Decimal(delta.total_seconds()) / Decimal(86400)

        base_price = Decimal("0.00")

        if self.booking_type == self.BookingType.HOURLY:
            hourly = self.spot.hourly_price
            units = max(
                Decimal("1"),
                total_hours.to_integral_value(rounding=ROUND_UP),
            )
            base_price = hourly * units
        elif self.booking_type == self.BookingType.DAILY:
            daily = self.spot.daily_price or (self.spot.hourly_price * Decimal("24"))
            units = max(
                Decimal("1"),
                total_days.to_integral_value(rounding=ROUND_UP),
            )
            base_price = daily * units
        elif self.booking_type == self.BookingType.NIGHT:
            nightly = self.spot.nightly_price or (
                self.spot.hourly_price * Decimal("10")
            )
            base_price = nightly
        elif self.booking_type == self.BookingType.WEEKLY:
            daily = self.spot.daily_price or (self.spot.hourly_price * Decimal("24"))
            units = max(
                Decimal("1"),
                (total_days / Decimal("7")).to_integral_value(rounding=ROUND_UP),
            )
            base_price = daily * Decimal("7") * units
        elif self.booking_type == self.BookingType.MONTHLY:
            monthly = self.spot.monthly_price or (
                (self.spot.daily_price or self.spot.hourly_price * Decimal("24"))
                * Decimal("30")
            )
            units = max(
                Decimal("1"),
                (total_days / Decimal("30")).to_integral_value(rounding=ROUND_UP),
            )
            base_price = monthly * units
        else:
            base_price = self.spot.hourly_price * max(
                Decimal("1"),
                total_hours.to_integral_value(rounding=ROUND_UP),
            )

        base_price = base_price.quantize(Decimal("0.01"))

        commission_percent = getattr(settings, "SERVICE_COMMISSION_PERCENT", 0)
        commission = (
            base_price * Decimal(commission_percent) / Decimal("100")
        ).quantize(Decimal("0.01"))
        total = (base_price + commission).quantize(Decimal("0.01"))
        self.total_price = total
        return total

    def mark_paid(self, payment_id: str | None = None) -> None:
        """
        Отметить бронь как оплаченную (вызывается из модуля payments по webhook).
        """
        self.is_paid = True
        self.status = self.Status.CONFIRMED
        if payment_id:
            self.external_payment_id = payment_id
        self.save(update_fields=["is_paid", "status", "external_payment_id"])

    @property
    def has_started(self) -> bool:
        return self.start_at <= timezone.now()

    @property
    def has_ended(self) -> bool:
        return self.end_at <= timezone.now()

    @property
    def duration(self) -> timedelta:
        return self.end_at - self.start_at


class WaitlistEntry(TimeStampedModel):
    """
    Запись в листе ожидания для занятого места.
    """

    class Status(models.TextChoices):
        WAITING = "waiting", "Ожидает"
        NOTIFIED = "notified", "Уведомлён"
        BOOKED = "booked", "Авто‑бронирование создано"
        CANCELLED = "cancelled", "Отменено"

    user = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name="waitlist_entries",
        verbose_name="Пользователь",
    )
    spot = models.ForeignKey(
        ParkingSpot,
        on_delete=models.CASCADE,
        related_name="waitlist_entries",
        verbose_name="Парковочное место",
    )
    desired_start = models.DateTimeField("Желаемое начало")
    desired_end = models.DateTimeField("Желаемое окончание")
    auto_book = models.BooleanField(
        "Авто‑бронирование",
        default=False,
        help_text="Если включено, при освобождении места будет создана бронь автоматически.",
    )
    status = models.CharField(
        "Статус",
        max_length=16,
        choices=Status.choices,
        default=Status.WAITING,
    )

    class Meta:
        verbose_name = "Запись в листе ожидания"
        verbose_name_plural = "Лист ожидания"
        ordering = ("-created_at",)
        unique_together = ("user", "spot", "desired_start", "desired_end")

    def __str__(self) -> str:
        return f"Waitlist #{self.pk} — {self.user} → {self.spot}"


class Complaint(TimeStampedModel):
    """
    Жалоба по бронированию/месту:
    - чужая машина;
    - пользователь не приехал;
    - частые отмены и т.п.
    """

    class Category(models.TextChoices):
        FOREIGN_CAR = "foreign_car", "Чужая машина на месте"
        NO_SHOW = "no_show", "Пользователь не приехал"
        NO_FREE_SPOT = "no_free_spot", "Не нашёл свободного места"
        OTHER = "other", "Другое"

    class Status(models.TextChoices):
        NEW = "new", "Новая"
        IN_PROGRESS = "in_progress", "В работе"
        RESOLVED = "resolved", "Решена"
        REJECTED = "rejected", "Отклонена"

    author = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name="complaints",
        verbose_name="Автор",
    )
    booking = models.ForeignKey(
        Booking,
        on_delete=models.SET_NULL,
        related_name="complaints",
        null=True,
        blank=True,
        verbose_name="Бронирование",
    )
    spot = models.ForeignKey(
        ParkingSpot,
        on_delete=models.SET_NULL,
        related_name="complaints",
        null=True,
        blank=True,
        verbose_name="Парковочное место",
    )

    category = models.CharField(
        "Категория",
        max_length=32,
        choices=Category.choices,
        default=Category.OTHER,
    )
    description = models.TextField("Описание", blank=True)

    status = models.CharField(
        "Статус",
        max_length=16,
        choices=Status.choices,
        default=Status.NEW,
    )

    class Meta:
        verbose_name = "Жалоба"
        verbose_name_plural = "Жалобы"
        ordering = ("-created_at",)

    def __str__(self) -> str:
        return f"Жалоба #{self.pk} ({self.get_category_display()})"


################################################################################
# File: parking\serializers.py
################################################################################

# backend/parking/serializers.py

from __future__ import annotations

from django.utils import timezone
from rest_framework import serializers

from core.utils import haversine_distance_km
from .models import Booking, Complaint, ParkingLot, ParkingSpot, WaitlistEntry


class ParkingLotSerializer(serializers.ModelSerializer):
    owner = serializers.ReadOnlyField(source="owner.username")
    spots_count = serializers.SerializerMethodField()

    class Meta:
        model = ParkingLot
        fields = (
            "id",
            "name",
            "city",
            "address",
            "parking_type",
            "description",
            "latitude",
            "longitude",
            "is_active",
            "is_approved",
            "is_private",
            "owner",
            "spots_count",
        )
        read_only_fields = ("id", "is_approved", "owner", "spots_count")

    def get_spots_count(self, obj: ParkingLot) -> int:
        return obj.spots.filter(status=ParkingSpot.SpotStatus.ACTIVE).count()

    def create(self, validated_data):
        request = self.context.get("request")
        owner = getattr(request, "user", None)
        if owner is not None and owner.is_authenticated:
            validated_data["owner"] = owner
        lot = super().create(validated_data)
        if lot.latitude is not None and lot.longitude is not None:
            lot.set_coordinates(lot.latitude, lot.longitude)
            lot.save(update_fields=["latitude", "longitude", "location"])
        return lot

    def update(self, instance, validated_data):
        lat = validated_data.get("latitude", instance.latitude)
        lng = validated_data.get("longitude", instance.longitude)
        instance = super().update(instance, validated_data)
        instance.set_coordinates(lat, lng)
        instance.save(update_fields=["latitude", "longitude", "location"])
        return instance


class ParkingSpotSerializer(serializers.ModelSerializer):
    lot_name = serializers.ReadOnlyField(source="lot.name")
    city = serializers.ReadOnlyField(source="lot.city")
    distance_km = serializers.SerializerMethodField()

    class Meta:
        model = ParkingSpot
        fields = (
            "id",
            "lot",
            "lot_name",
            "city",
            "name",
            "description",
            "vehicle_type",
            "is_covered",
            "has_ev_charging",
            "is_24_7",
            "max_height_m",
            "hourly_price",
            "nightly_price",
            "daily_price",
            "monthly_price",
            "allow_dynamic_pricing",
            "status",
            "distance_km",
        )
        read_only_fields = ("id", "distance_km")

    def get_distance_km(self, obj: ParkingSpot):
        # Если в viewset уже посчитали и повесили атрибут — используем его.
        distance = getattr(obj, "distance_km", None)
        if distance is not None:
            return round(float(distance), 2)

        request = self.context.get("request")
        if not request:
            return None
        lat_param = request.query_params.get("lat")
        lng_param = request.query_params.get("lng")
        if not lat_param or not lng_param:
            return None
        if obj.lot.latitude is None or obj.lot.longitude is None:
            return None

        try:
            lat = float(lat_param)
            lng = float(lng_param)
        except (TypeError, ValueError):
            return None
        return round(haversine_distance_km(lat, lng, obj.lot.latitude, obj.lot.longitude), 2)


class BookingSerializer(serializers.ModelSerializer):
    user = serializers.ReadOnlyField(source="user.username")
    spot_name = serializers.ReadOnlyField(source="spot.name")
    lot_name = serializers.ReadOnlyField(source="spot.lot.name")

    class Meta:
        model = Booking
        fields = (
            "id",
            "user",
            "spot",
            "spot_name",
            "lot_name",
            "vehicle",
            "booking_type",
            "start_at",
            "end_at",
            "status",
            "total_price",
            "currency",
            "is_paid",
            "created_at",
            "updated_at",
            "external_payment_id",
        )
        read_only_fields = (
            "id",
            "user",
            "status",
            "total_price",
            "currency",
            "is_paid",
            "created_at",
            "updated_at",
            "external_payment_id",
            "spot_name",
            "lot_name",
        )

    def validate(self, attrs):
        request = self.context["request"]
        spot: ParkingSpot = attrs.get("spot", getattr(self.instance, "spot", None))
        start_at = attrs.get("start_at", getattr(self.instance, "start_at", None))
        end_at = attrs.get("end_at", getattr(self.instance, "end_at", None))
        booking_type = attrs.get(
            "booking_type", getattr(self.instance, "booking_type", Booking.BookingType.HOURLY)
        )

        if not spot or not start_at or not end_at:
            raise serializers.ValidationError("Необходимо указать место и интервал бронирования.")

        if start_at >= end_at:
            raise serializers.ValidationError("Дата начала должна быть меньше даты окончания.")

        if start_at < timezone.now():
            raise serializers.ValidationError("Нельзя создавать бронирование в прошлом.")

        if not spot.is_active:
            raise serializers.ValidationError("Выбранное место сейчас недоступно для бронирования.")

        exclude_id = self.instance.id if self.instance else None
        if not Booking.is_spot_available(spot, start_at, end_at, exclude_booking_id=exclude_id):
            raise serializers.ValidationError("На выбранный период это место уже забронировано.")

        attrs["spot"] = spot
        attrs["start_at"] = start_at
        attrs["end_at"] = end_at
        attrs["booking_type"] = booking_type
        return attrs

    def create(self, validated_data):
        request = self.context["request"]
        user = request.user
        booking = Booking(
            user=user,
            **validated_data,
        )
        booking.total_price = booking.calculate_price()
        booking.currency = "RUB"
        booking.status = Booking.Status.PENDING
        booking.save()
        return booking

    def update(self, instance, validated_data):
        for field in ("spot", "start_at", "end_at", "booking_type", "vehicle"):
            if field in validated_data:
                setattr(instance, field, validated_data[field])

        # Разрешаем менять только PENDING‑брони (упрощение)
        if instance.status != Booking.Status.PENDING:
            raise serializers.ValidationError("Можно редактировать только бронирования в статусе 'Ожидает оплаты'.")

        instance.total_price = instance.calculate_price()
        instance.save()
        return instance


class WaitlistEntrySerializer(serializers.ModelSerializer):
    user = serializers.ReadOnlyField(source="user.username")
    spot_name = serializers.ReadOnlyField(source="spot.name")

    class Meta:
        model = WaitlistEntry
        fields = (
            "id",
            "user",
            "spot",
            "spot_name",
            "desired_start",
            "desired_end",
            "auto_book",
            "status",
            "created_at",
            "updated_at",
        )
        read_only_fields = ("id", "user", "spot_name", "status", "created_at", "updated_at")

    def create(self, validated_data):
        request = self.context["request"]
        user = request.user
        entry = WaitlistEntry.objects.create(user=user, **validated_data)
        return entry


class ComplaintSerializer(serializers.ModelSerializer):
    author = serializers.ReadOnlyField(source="author.username")
    spot_name = serializers.ReadOnlyField(source="spot.name")
    booking_id = serializers.ReadOnlyField(source="booking.id")

    class Meta:
        model = Complaint
        fields = (
            "id",
            "author",
            "booking",
            "booking_id",
            "spot",
            "spot_name",
            "category",
            "description",
            "status",
            "created_at",
            "updated_at",
        )
        read_only_fields = ("id", "author", "status", "created_at", "updated_at", "spot_name", "booking_id")

    def create(self, validated_data):
        request = self.context["request"]
        user = request.user
        complaint = Complaint.objects.create(author=user, **validated_data)
        return complaint


################################################################################
# File: parking\tasks.py
################################################################################

# backend/parking/tasks.py

from __future__ import annotations

from datetime import timedelta

from celery import shared_task
from django.utils import timezone

from .models import Booking


@shared_task
def expire_unpaid_bookings() -> str:
    """
    Фоновая задача: помечает как EXPIRED неоплаченные бронирования,
    у которых время начала уже давно прошло.

    Подключена в CELERY_BEAT_SCHEDULE как parking.tasks.expire_unpaid_bookings.
    """

    now = timezone.now()
    grace = timedelta(minutes=15)  # "льготный" период
    qs = Booking.objects.filter(
        status=Booking.Status.PENDING,
        is_paid=False,
        start_at__lt=now - grace,
    )
    count = qs.count()
    for booking in qs:
        booking.status = Booking.Status.EXPIRED
        booking.save(update_fields=["status"])
    return f"Expired {count} unpaid bookings"


################################################################################
# File: parking\urls.py
################################################################################

# backend/parking/urls.py

from django.urls import path

app_name = "parking"

urlpatterns: list = [
    # На данный момент все HTML‑страницы подключаются напрямую из config.urls.
]


################################################################################
# File: parking\views.py
################################################################################

# backend/parking/views.py

from __future__ import annotations

from typing import Any, Iterable, List

from django.contrib.auth.mixins import LoginRequiredMixin
from django.db.models import Q
from django.shortcuts import redirect
from django.urls import reverse
from django.views.generic import TemplateView
from rest_framework import permissions, status, viewsets
from rest_framework.response import Response

from core.permissions import IsAdminOrReadOnly
from core.utils import haversine_distance_km, parse_float
from vehicles.models import Vehicle

from .models import Booking, Complaint, ParkingLot, ParkingSpot, WaitlistEntry
from .serializers import (
    BookingSerializer,
    ComplaintSerializer,
    ParkingLotSerializer,
    ParkingSpotSerializer,
    WaitlistEntrySerializer,
)


# =======================
#   DRF ViewSets (API)
# =======================


class ParkingLotViewSet(viewsets.ModelViewSet):
    """
    CRUD по объектам парковки.

    - GET /api/parking/lots/ — список (фильтрация по городу/типу)
    - POST /api/parking/lots/ — создать (только владельцы/админы)
    """

    serializer_class = ParkingLotSerializer
    permission_classes = [permissions.IsAuthenticatedOrReadOnly]

    def get_queryset(self):
        qs = ParkingLot.objects.select_related("owner")
        user = self.request.user
        if not user.is_authenticated or (not user.is_staff and not getattr(user, "is_owner", False)):
            qs = qs.filter(is_active=True, is_approved=True)

        city = self.request.query_params.get("city")
        if city:
            qs = qs.filter(city__iexact=city)

        parking_type = self.request.query_params.get("parking_type")
        if parking_type:
            qs = qs.filter(parking_type=parking_type)

        return qs

    def perform_create(self, serializer):
        user = self.request.user
        if not user.is_authenticated or not getattr(user, "is_owner", False):
            raise permissions.PermissionDenied(
                "Создавать объекты парковки могут только пользователи с ролью 'owner' или администраторы."
            )
        serializer.save(owner=user)


class ParkingSpotViewSet(viewsets.ModelViewSet):
    """
    CRUD по парковочным местам.

    - GET /api/parking/spots/?lat=...&lng=...&radius_km=2 — места рядом
    - Фильтры: ?city=, ?vehicle_type=, ?max_price=, ?has_ev=1, ?covered=1, ?is_24_7=1
    """

    serializer_class = ParkingSpotSerializer
    permission_classes = [permissions.IsAuthenticatedOrReadOnly]

    def get_queryset(self):
        qs = (
            ParkingSpot.objects.select_related("lot", "lot__owner")
            .all()
        )
        user = self.request.user

        if self.request.method in ("GET", "HEAD", "OPTIONS"):
            qs = qs.filter(
                status=ParkingSpot.SpotStatus.ACTIVE,
                lot__is_active=True,
                lot__is_approved=True,
            )
        else:
            # Управлять местами может только владелец/админ
            if not user.is_authenticated or (not getattr(user, "is_owner", False) and not user.is_superuser):
                return ParkingSpot.objects.none()
            qs = qs.filter(lot__owner=user)

        # Фильтрация
        params = self.request.query_params
        city = params.get("city")
        if city:
            qs = qs.filter(lot__city__iexact=city)

        vehicle_type = params.get("vehicle_type")
        if vehicle_type:
            qs = qs.filter(vehicle_type=vehicle_type)

        max_price = parse_float(params.get("max_price"))
        if max_price is not None:
            qs = qs.filter(hourly_price__lte=max_price)

        has_ev = params.get("has_ev")
        if has_ev == "1":
            qs = qs.filter(has_ev_charging=True)

        covered = params.get("covered")
        if covered == "1":
            qs = qs.filter(is_covered=True)

        is_24_7 = params.get("is_24_7")
        if is_24_7 == "1":
            qs = qs.filter(is_24_7=True)

        return qs

    def list(self, request, *args, **kwargs):
        queryset = self.filter_queryset(self.get_queryset())

        lat = parse_float(request.query_params.get("lat"))
        lng = parse_float(request.query_params.get("lng"))
        radius_km = parse_float(request.query_params.get("radius_km"))

        if lat is not None and lng is not None and radius_km is not None:
            # Python‑фильтрация по расстоянию (работает и без PostGIS)
            filtered: List[ParkingSpot] = []
            for spot in queryset:
                lot = spot.lot
                if lot.latitude is None or lot.longitude is None:
                    continue
                distance = haversine_distance_km(lat, lng, lot.latitude, lot.longitude)
                if distance <= radius_km:
                    spot.distance_km = distance  # для сериализатора
                    filtered.append(spot)
            queryset = filtered

        page = self.paginate_queryset(queryset)
        if page is not None:
            serializer = self.get_serializer(page, many=True)
            return self.get_paginated_response(serializer.data)

        serializer = self.get_serializer(queryset, many=True)
        return Response(serializer.data)


class BookingViewSet(viewsets.ModelViewSet):
    """
    Бронирования.

    - Пользователь видит свои бронирования.
    - Владелец видит свои бронирования и брони по своим местам.
    """

    serializer_class = BookingSerializer
    permission_classes = [permissions.IsAuthenticated]

    def get_queryset(self):
        user = self.request.user
        qs = (
            Booking.objects.select_related("spot", "spot__lot", "user", "vehicle")
            .all()
        )
        if not user.is_authenticated:
            return Booking.objects.none()

        if user.is_superuser:
            return qs

        if getattr(user, "is_owner", False):
            return qs.filter(Q(user=user) | Q(spot__lot__owner=user))
        return qs.filter(user=user)

    def perform_create(self, serializer):
        booking = serializer.save()
        return booking

    def destroy(self, request, *args, **kwargs):
        """
        Отмена бронирования: помечаем как CANCELLED,
        если оно ещё не началось.
        """
        instance: Booking = self.get_object()
        if instance.has_started:
            return Response(
                {"detail": "Нельзя отменить уже начавшееся бронирование."},
                status=status.HTTP_400_BAD_REQUEST,
            )
        instance.status = Booking.Status.CANCELLED
        instance.save(update_fields=["status"])
        return Response(status=status.HTTP_204_NO_CONTENT)


class WaitlistViewSet(viewsets.ModelViewSet):
    """
    Лист ожидания. Пользователь управляет только своими записями.
    Админ может видеть всё.
    """

    serializer_class = WaitlistEntrySerializer
    permission_classes = [permissions.IsAuthenticated]

    def get_queryset(self):
        user = self.request.user
        qs = WaitlistEntry.objects.select_related("spot", "spot__lot", "user")
        if user.is_superuser:
            return qs
        return qs.filter(user=user)


class ComplaintViewSet(viewsets.ModelViewSet):
    """
    Жалобы. Создатель видит свои, админ — все.
    """

    serializer_class = ComplaintSerializer
    permission_classes = [permissions.IsAuthenticated]

    def get_queryset(self):
        user = self.request.user
        qs = Complaint.objects.select_related("author", "spot", "booking")
        if user.is_superuser:
            return qs
        return qs.filter(author=user)

    def perform_create(self, serializer):
        serializer.save(author=self.request.user)


# =======================
#   HTML-вьюхи
# =======================


class LandingPageView(TemplateView):
    """
    Лендинг с картой и списком парковок/мест.
    """

    template_name = "parking/landing.html"

    def get_context_data(self, **kwargs: Any):
        ctx = super().get_context_data(**kwargs)
        lots = (
            ParkingLot.objects.filter(is_active=True, is_approved=True)
            .select_related("owner")
            .order_by("city", "name")[:50]
        )
        spots = (
            ParkingSpot.objects.filter(
                status=ParkingSpot.SpotStatus.ACTIVE,
                lot__in=lots,
            )
            .select_related("lot", "lot__owner")
            .order_by("lot__city", "lot__name", "name")[:100]
        )
        ctx["lots"] = lots
        ctx["spots"] = spots
        return ctx


class UserDashboardView(LoginRequiredMixin, TemplateView):
    """
    Личный кабинет водителя: его машины и бронирования.
    """

    template_name = "parking/user_dashboard.html"

    def get_context_data(self, **kwargs: Any):
        ctx = super().get_context_data(**kwargs)
        user = self.request.user
        vehicles = Vehicle.objects.filter(owner=user).order_by("-created_at")
        bookings = (
            Booking.objects.filter(user=user)
            .select_related("spot", "spot__lot")
            .order_by("-start_at")
        )
        ctx["vehicles"] = vehicles
        ctx["bookings"] = bookings
        return ctx


class OwnerDashboardView(LoginRequiredMixin, TemplateView):
    """
    Кабинет владельца: его паркинги, места и бронирования по ним.
    """

    template_name = "parking/owner_dashboard.html"

    def dispatch(self, request, *args, **kwargs):
        user = request.user
        if not (getattr(user, "is_owner", False) or user.is_superuser):
            # Если не владелец — отправляем в обычный кабинет
            return redirect("user_dashboard")
        return super().dispatch(request, *args, **kwargs)

    def get_context_data(self, **kwargs: Any):
        ctx = super().get_context_data(**kwargs)
        user = self.request.user
        lots = (
            ParkingLot.objects.filter(owner=user)
            .prefetch_related("spots")
            .order_by("city", "name")
        )
        spots = ParkingSpot.objects.filter(lot__owner=user).select_related("lot")
        bookings = (
            Booking.objects.filter(spot__lot__owner=user)
            .select_related("spot", "spot__lot", "user", "vehicle")
            .order_by("-start_at")
        )
        ctx["lots"] = lots
        ctx["spots"] = spots
        ctx["bookings"] = bookings
        return ctx


################################################################################
# File: parking\migrations\0001_initial.py
################################################################################

# Generated by Django 5.2.8 on 2025-11-21 21:34

import django.db.models.deletion
import parking.models
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('vehicles', '0001_initial'),
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='Booking',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('created_at', models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')),
                ('updated_at', models.DateTimeField(auto_now=True, verbose_name='Дата обновления')),
                ('booking_type', models.CharField(choices=[('hourly', 'Почасовая'), ('daily', 'Суточная'), ('night', 'Ночная'), ('weekly', 'Недельная'), ('monthly', 'Месячная')], default='hourly', max_length=16, verbose_name='Тип бронирования')),
                ('start_at', models.DateTimeField(verbose_name='Начало брони')),
                ('end_at', models.DateTimeField(verbose_name='Окончание брони')),
                ('status', models.CharField(choices=[('pending', 'Ожидает оплаты'), ('confirmed', 'Подтверждена'), ('active', 'Активна'), ('completed', 'Завершена'), ('cancelled', 'Отменена'), ('expired', 'Истекла')], default='pending', max_length=16, verbose_name='Статус')),
                ('total_price', models.DecimalField(decimal_places=2, max_digits=10, verbose_name='Итоговая стоимость, ₽')),
                ('currency', models.CharField(default='RUB', max_length=8, verbose_name='Валюта')),
                ('is_paid', models.BooleanField(default=False, verbose_name='Оплачено')),
                ('external_payment_id', models.CharField(blank=True, help_text='Связка с платежом у провайдера (например, YooKassa payment_id).', max_length=64, verbose_name='ID платежа провайдера')),
                ('user', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='bookings', to=settings.AUTH_USER_MODEL, verbose_name='Пользователь')),
                ('vehicle', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='bookings', to='vehicles.vehicle', verbose_name='Транспорт')),
            ],
            options={
                'verbose_name': 'Бронирование',
                'verbose_name_plural': 'Бронирования',
                'ordering': ('-start_at',),
            },
        ),
        migrations.CreateModel(
            name='ParkingLot',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('created_at', models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')),
                ('updated_at', models.DateTimeField(auto_now=True, verbose_name='Дата обновления')),
                ('name', models.CharField(max_length=255, verbose_name='Название')),
                ('city', models.CharField(max_length=100, verbose_name='Город')),
                ('address', models.CharField(max_length=255, verbose_name='Адрес')),
                ('parking_type', models.CharField(choices=[('yard', 'Дворовая парковка'), ('underground', 'Подземная парковка'), ('multilevel', 'Многоуровневая парковка'), ('street', 'Уличная парковка'), ('office', 'Офисная парковка'), ('home', 'Домашнее место')], default='yard', max_length=32, verbose_name='Тип парковки')),
                ('description', models.TextField(blank=True, verbose_name='Описание')),
                ('location', parking.models.PointField(blank=True, null=True, verbose_name='Точка на карте')),
                ('latitude', models.FloatField(blank=True, null=True, verbose_name='Широта')),
                ('longitude', models.FloatField(blank=True, null=True, verbose_name='Долгота')),
                ('is_active', models.BooleanField(default=True, verbose_name='Активен')),
                ('is_approved', models.BooleanField(default=False, help_text='Одобряется администратором перед публикацией.', verbose_name='Одобрен модерацией')),
                ('is_private', models.BooleanField(default=False, help_text='Если включено, объект виден только по прямым ссылкам/владельцу.', verbose_name='Приватный')),
                ('owner', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='parking_lots', to=settings.AUTH_USER_MODEL, verbose_name='Владелец')),
            ],
            options={
                'verbose_name': 'Объект парковки',
                'verbose_name_plural': 'Объекты парковки',
                'ordering': ('name',),
            },
        ),
        migrations.CreateModel(
            name='ParkingSpot',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('created_at', models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')),
                ('updated_at', models.DateTimeField(auto_now=True, verbose_name='Дата обновления')),
                ('name', models.CharField(max_length=64, verbose_name='Название/номер места')),
                ('description', models.TextField(blank=True, verbose_name='Описание')),
                ('vehicle_type', models.CharField(choices=[('car', 'Легковой автомобиль'), ('moto', 'Мотоцикл'), ('commercial', 'Коммерческий транспорт')], default='car', max_length=16, verbose_name='Тип транспорта')),
                ('is_covered', models.BooleanField(default=False, verbose_name='Крытое место')),
                ('has_ev_charging', models.BooleanField(default=False, verbose_name='Есть зарядка')),
                ('is_24_7', models.BooleanField(default=True, verbose_name='Круглосуточно')),
                ('max_height_m', models.DecimalField(blank=True, decimal_places=2, max_digits=4, null=True, verbose_name='Максимальная высота (м)')),
                ('hourly_price', models.DecimalField(decimal_places=2, max_digits=8, verbose_name='Цена за час, ₽')),
                ('nightly_price', models.DecimalField(blank=True, decimal_places=2, max_digits=8, null=True, verbose_name='Цена за ночь, ₽')),
                ('daily_price', models.DecimalField(blank=True, decimal_places=2, max_digits=8, null=True, verbose_name='Цена за сутки, ₽')),
                ('monthly_price', models.DecimalField(blank=True, decimal_places=2, max_digits=9, null=True, verbose_name='Цена за месяц, ₽')),
                ('allow_dynamic_pricing', models.BooleanField(default=False, help_text='Если включено, тариф может корректироваться рекомендациями AI.', verbose_name='Динамическая цена (AI)')),
                ('status', models.CharField(choices=[('active', 'Активно'), ('inactive', 'Неактивно')], default='active', max_length=16, verbose_name='Статус')),
                ('lot', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='spots', to='parking.parkinglot', verbose_name='Объект парковки')),
            ],
            options={
                'verbose_name': 'Парковочное место',
                'verbose_name_plural': 'Парковочные места',
                'ordering': ('lot__name', 'name'),
            },
        ),
        migrations.CreateModel(
            name='Complaint',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('created_at', models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')),
                ('updated_at', models.DateTimeField(auto_now=True, verbose_name='Дата обновления')),
                ('category', models.CharField(choices=[('foreign_car', 'Чужая машина на месте'), ('no_show', 'Пользователь не приехал'), ('no_free_spot', 'Не нашёл свободного места'), ('other', 'Другое')], default='other', max_length=32, verbose_name='Категория')),
                ('description', models.TextField(blank=True, verbose_name='Описание')),
                ('status', models.CharField(choices=[('new', 'Новая'), ('in_progress', 'В работе'), ('resolved', 'Решена'), ('rejected', 'Отклонена')], default='new', max_length=16, verbose_name='Статус')),
                ('author', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='complaints', to=settings.AUTH_USER_MODEL, verbose_name='Автор')),
                ('booking', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='complaints', to='parking.booking', verbose_name='Бронирование')),
                ('spot', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='complaints', to='parking.parkingspot', verbose_name='Парковочное место')),
            ],
            options={
                'verbose_name': 'Жалоба',
                'verbose_name_plural': 'Жалобы',
                'ordering': ('-created_at',),
            },
        ),
        migrations.AddField(
            model_name='booking',
            name='spot',
            field=models.ForeignKey(on_delete=django.db.models.deletion.PROTECT, related_name='bookings', to='parking.parkingspot', verbose_name='Парковочное место'),
        ),
        migrations.CreateModel(
            name='WaitlistEntry',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('created_at', models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')),
                ('updated_at', models.DateTimeField(auto_now=True, verbose_name='Дата обновления')),
                ('desired_start', models.DateTimeField(verbose_name='Желаемое начало')),
                ('desired_end', models.DateTimeField(verbose_name='Желаемое окончание')),
                ('auto_book', models.BooleanField(default=False, help_text='Если включено, при освобождении места будет создана бронь автоматически.', verbose_name='Авто‑бронирование')),
                ('status', models.CharField(choices=[('waiting', 'Ожидает'), ('notified', 'Уведомлён'), ('booked', 'Авто‑бронирование создано'), ('cancelled', 'Отменено')], default='waiting', max_length=16, verbose_name='Статус')),
                ('spot', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='waitlist_entries', to='parking.parkingspot', verbose_name='Парковочное место')),
                ('user', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='waitlist_entries', to=settings.AUTH_USER_MODEL, verbose_name='Пользователь')),
            ],
            options={
                'verbose_name': 'Запись в листе ожидания',
                'verbose_name_plural': 'Лист ожидания',
                'ordering': ('-created_at',),
                'unique_together': {('user', 'spot', 'desired_start', 'desired_end')},
            },
        ),
    ]


################################################################################
# File: parking\migrations\0002_parkinglot_stress_index_parkingspot_occupancy_7d.py
################################################################################

# Generated by Django 5.2.8 on 2025-11-22 11:21

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('parking', '0001_initial'),
    ]

    operations = [
        migrations.AddField(
            model_name='parkinglot',
            name='stress_index',
            field=models.FloatField(default=0.0, help_text='Средняя загруженность мест за последние 7 дней. Обновляется фоновыми задачами AI.', verbose_name='Индекс загруженности (0..1)'),
        ),
        migrations.AddField(
            model_name='parkingspot',
            name='occupancy_7d',
            field=models.FloatField(default=0.0, help_text='Доля времени, когда место было занято за последние 7 дней. Обновляется фоновыми задачами AI.', verbose_name='Загруженность за 7 дней (0..1)'),
        ),
    ]


################################################################################
# File: parking\migrations\__init__.py
################################################################################



################################################################################
# File: payments\__init__.py
################################################################################

default_app_config = "payments.apps.PaymentsConfig"


################################################################################
# File: payments\admin.py
################################################################################

from django.contrib import admin

from .models import Payment


@admin.register(Payment)
class PaymentAdmin(admin.ModelAdmin):
    list_display = (
        "id",
        "booking",
        "payer",
        "provider",
        "provider_payment_id",
        "amount",
        "currency",
        "status",
        "success",
        "failure",
        "created_at",
    )
    list_filter = (
        "provider",
        "status",
        "success",
        "failure",
        "created_at",
    )
    search_fields = ("provider_payment_id", "booking__id", "payer__username")
    autocomplete_fields = ("booking", "payer")


################################################################################
# File: payments\apps.py
################################################################################

from django.apps import AppConfig


class PaymentsConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "payments"
    verbose_name = "Платежи"


################################################################################
# File: payments\models.py
################################################################################

from __future__ import annotations

from decimal import Decimal
from typing import Any, Optional

from django.conf import settings
from django.db import models
from django.utils.translation import gettext_lazy as _

from core.models import TimeStampedModel


class Payment(TimeStampedModel):
    """
    Платёж за бронирование через внешнего провайдера (по умолчанию — YooKassa).

    Для простоты в текущей реализации у каждой брони может быть не более
    одного связанного платежа (OneToOne), который используется повторно
    при повторных попытках оплаты, пока не станет успешным или не будет
    отменён/завершён с ошибкой.
    """

    class Provider(models.TextChoices):
        YOOKASSA = "yookassa", "YooKassa"

    class Status(models.TextChoices):
        CREATED = "created", _("Создан")
        PENDING = "pending", _("Ожидает оплаты")
        SUCCEEDED = "succeeded", _("Успешен")
        CANCELLED = "cancelled", _("Отменён")
        FAILED = "failed", _("Ошибка")

    booking = models.OneToOneField(
        "parking.Booking",
        on_delete=models.CASCADE,
        related_name="payment",
        verbose_name=_("Бронь"),
    )
    payer = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name="payments",
        verbose_name=_("Плательщик"),
    )

    provider = models.CharField(
        _("Провайдер"),
        max_length=32,
        choices=Provider.choices,
        default=Provider.YOOKASSA,
    )
    provider_payment_id = models.CharField(
        _("ID платежа у провайдера"),
        max_length=128,
        blank=True,
        db_index=True,
    )

    amount = models.DecimalField(
        _("Сумма"),
        max_digits=10,
        decimal_places=2,
    )
    currency = models.CharField(
        _("Валюта"),
        max_length=8,
        default="RUB",
    )

    status = models.CharField(
        _("Статус"),
        max_length=16,
        choices=Status.choices,
        default=Status.CREATED,
        db_index=True,
    )
    success = models.BooleanField(_("Успешен"), default=False)
    failure = models.BooleanField(_("Ошибка"), default=False)

    raw_response = models.JSONField(
        _("Ответ провайдера"),
        null=True,
        blank=True,
        help_text=_("Сырые данные, вернувшиеся при создании платежа."),
    )
    raw_webhook = models.JSONField(
        _("Последний webhook"),
        null=True,
        blank=True,
        help_text=_("Последнее уведомление провайдера по этому платежу."),
    )

    class Meta:
        verbose_name = _("Платёж")
        verbose_name_plural = _("Платежи")
        ordering = ("-created_at",)

    def __str__(self) -> str:
        return f"Payment #{self.pk} for booking #{self.booking_id}"

    @property
    def is_active(self) -> bool:
        """
        "Активный" платёж — тот, который ещё может сменить состояние на успешное.
        """
        return self.status in {self.Status.CREATED, self.Status.PENDING}

    def _update_status(
        self,
        status: str,
        success: bool,
        failure: bool,
        webhook_data: Optional[dict[str, Any]] = None,
    ) -> None:
        self.status = status
        self.success = success
        self.failure = failure
        if webhook_data is not None:
            self.raw_webhook = webhook_data
        self.save(
            update_fields=[
                "status",
                "success",
                "failure",
                "raw_webhook",
                "updated_at",
            ]
        )

    def mark_succeeded(self, webhook_data: Optional[dict[str, Any]] = None) -> None:
        """
        Помечает платёж как успешный и вызывает booking.mark_paid(...).

        Вызывается из обработчика вебхуков YooKassa после подтверждения
        успешного платежа.
        """
        self._update_status(
            status=self.Status.SUCCEEDED,
            success=True,
            failure=False,
            webhook_data=webhook_data,
        )

        # Обновляем связанную бронь.
        booking = self.booking
        if booking:
            booking.mark_paid(payment_id=self.provider_payment_id or "")

    def mark_failed(self, webhook_data: Optional[dict[str, Any]] = None) -> None:
        """
        Помечает платёж как неуспешный (ошибка).
        """
        self._update_status(
            status=self.Status.FAILED,
            success=False,
            failure=True,
            webhook_data=webhook_data,
        )

    def mark_cancelled(self, webhook_data: Optional[dict[str, Any]] = None) -> None:
        """
        Помечает платёж как отменённый пользователем или провайдером.
        """
        self._update_status(
            status=self.Status.CANCELLED,
            success=False,
            failure=True,
            webhook_data=webhook_data,
        )


################################################################################
# File: payments\providers.py
################################################################################

from __future__ import annotations

import uuid
from decimal import Decimal
from typing import Any, Tuple

from django.conf import settings
from django.core.exceptions import ImproperlyConfigured

try:
    # Официальный синхронный SDK YooKassa
    from yookassa import Configuration, Payment as YooPayment  # type: ignore[import]
except ImportError:  # pragma: no cover - мягкий фолбэк
    Configuration = None
    YooPayment = None


class YooKassaError(Exception):
    """Базовая ошибка при работе с YooKassa."""


def _configure_yookassa() -> None:
    """
    Настраивает SDK YooKassa из Django settings.

    Требуются:
    - YOOKASSA_SHOP_ID
    - YOOKASSA_SECRET_KEY
    """
    if Configuration is None or YooPayment is None:
        raise ImproperlyConfigured(
            "Пакет 'yookassa' не установлен. Добавьте его в requirements.txt."
        )

    shop_id = getattr(settings, "YOOKASSA_SHOP_ID", "")
    secret_key = getattr(settings, "YOOKASSA_SECRET_KEY", "")
    if not shop_id or not secret_key:
        raise ImproperlyConfigured(
            "Не заданы YOOKASSA_SHOP_ID и/или YOOKASSA_SECRET_KEY в настройках."
        )

    Configuration.account_id = shop_id
    Configuration.secret_key = secret_key


def create_yookassa_payment(booking) -> Tuple[str, str, dict[str, Any]]:
    """
    Создаёт платёж в YooKassa для указанной брони.

    Возвращает:
        (payment_url, provider_payment_id, raw_response_dict)

    Все сетевые вызовы инкапсулированы здесь.
    """
    _configure_yookassa()

    from parking.models import Booking  # локальный импорт, чтобы избежать циклов

    if not isinstance(booking, Booking):
        raise YooKassaError("create_yookassa_payment ожидает экземпляр Booking.")

    amount = booking.total_price
    if not isinstance(amount, Decimal):
        amount = Decimal(str(amount))

    amount_str = str(amount.quantize(Decimal("0.01")))
    currency = booking.currency or "RUB"
    return_url = getattr(settings, "YOOKASSA_RETURN_URL", "")

    description = f"Оплата брони #{booking.id} — {booking.spot}"

    payload: dict[str, Any] = {
        "amount": {
            "value": amount_str,
            "currency": currency,
        },
        "confirmation": {
            "type": "redirect",
            "return_url": return_url,
        },
        "capture": True,
        "description": description,
        "metadata": {
            "booking_id": str(booking.id),
            "user_id": str(booking.user_id),
        },
    }

    try:
        payment = YooPayment.create(payload, uuid.uuid4())
    except Exception as exc:  # noqa: BLE001
        raise YooKassaError(str(exc)) from exc

    confirmation = getattr(payment, "confirmation", None)
    payment_url = getattr(confirmation, "confirmation_url", None) if confirmation else None
    provider_payment_id = getattr(payment, "id", None)

    if not payment_url or not provider_payment_id:
        raise YooKassaError(
            "Некорректный ответ от YooKassa: не получены id или URL оплаты."
        )

    raw_response = {
        "id": provider_payment_id,
        "status": getattr(payment, "status", None),
    }

    return payment_url, provider_payment_id, raw_response


################################################################################
# File: payments\serializers.py
################################################################################

from __future__ import annotations

from decimal import Decimal

from django.utils import timezone
from rest_framework import serializers

from parking.models import Booking
from .models import Payment
from .providers import YooKassaError, create_yookassa_payment


class PaymentSerializer(serializers.ModelSerializer):
    """
    Сериализатор для платежей.

    Политика повторных оплат:
    - если для брони уже существует платёж в статусе SUCCEEDED — новый
      платёж создать нельзя;
    - если платёж существует, но ещё неуспешен (CREATED/PENDING/FAILED/CANCELLED),
      он переиспользуется: заново инициализируется через YooKassa и возвращается
      с актуальным payment_url.
    """

    payer = serializers.ReadOnlyField(source="payer.username")
    booking = serializers.PrimaryKeyRelatedField(read_only=True)
    booking_id = serializers.PrimaryKeyRelatedField(
        queryset=Booking.objects.all(),
        source="booking",
        write_only=True,
    )
    payment_url = serializers.CharField(read_only=True)

    class Meta:
        model = Payment
        fields = (
            "id",
            "payer",
            "booking",
            "booking_id",
            "provider",
            "provider_payment_id",
            "amount",
            "currency",
            "status",
            "success",
            "failure",
            "created_at",
            "updated_at",
            "payment_url",
        )
        read_only_fields = (
            "id",
            "payer",
            "booking",
            "provider",
            "provider_payment_id",
            "amount",
            "currency",
            "status",
            "success",
            "failure",
            "created_at",
            "updated_at",
        )

    def validate(self, attrs: dict) -> dict:
        request = self.context["request"]
        user = request.user

        booking: Booking = attrs["booking"]

        # Бронь должна принадлежать текущему пользователю
        if booking.user_id != user.id:
            raise serializers.ValidationError(
                "Нельзя создавать платёж для чужой брони."
            )

        # Бронь должна ожидать оплаты
        if booking.is_paid or booking.status != Booking.Status.PENDING:
            raise serializers.ValidationError(
                "Платёж можно создать только для брони в статусе «Ожидает оплаты»."
            )

        now = timezone.now()
        if booking.status in (
            Booking.Status.CANCELLED,
            Booking.Status.EXPIRED,
        ) or booking.end_at <= now:
            raise serializers.ValidationError(
                "Нельзя создать платёж для отменённой, истекшей или прошлой брони."
            )

        if booking.total_price <= Decimal("0"):
            raise serializers.ValidationError(
                "Сумма бронирования должна быть больше нуля."
            )

        return attrs

    def create(self, validated_data: dict) -> Payment:
        request = self.context["request"]
        user = request.user
        booking: Booking = validated_data["booking"]

        # Пытаемся переиспользовать существующий платёж (если есть)
        existing: Payment | None = getattr(booking, "payment", None)
        if existing is not None:
            if existing.status == Payment.Status.SUCCEEDED:
                raise serializers.ValidationError(
                    "Для этой брони уже существует успешный платёж."
                )
            payment = existing
        else:
            payment = Payment(
                booking=booking,
                payer=user,
                amount=booking.total_price,
                currency=booking.currency or "RUB",
            )

        try:
            payment_url, provider_payment_id, raw = create_yookassa_payment(booking)
        except YooKassaError as exc:
            raise serializers.ValidationError({"detail": str(exc)}) from exc

        payment.provider = Payment.Provider.YOOKASSA
        payment.provider_payment_id = provider_payment_id
        payment.status = Payment.Status.PENDING
        payment.success = False
        payment.failure = False
        payment.raw_response = raw
        payment.save()

        # Временный атрибут, чтобы добавить URL в ответ сериализатора
        payment.payment_url = payment_url  # type: ignore[attr-defined]

        return payment


################################################################################
# File: payments\tasks.py
################################################################################

from __future__ import annotations

from celery import shared_task

from .models import Payment


@shared_task
def check_stale_payments() -> str:
    """
    Заготовка фоновой задачи для проверки "зависших" платежей.

    В будущей версии здесь можно реализовать:
    - поиск платежей в статусе PENDING слишком долго;
    - запрос их фактического состояния у YooKassa;
    - перевод в FAILED/CANCELLED при необходимости.
    """
    pending_count = Payment.objects.filter(status=Payment.Status.PENDING).count()
    return f"Pending payments count: {pending_count}"


################################################################################
# File: payments\views.py
################################################################################

from __future__ import annotations

from django.conf import settings
from rest_framework import mixins, permissions, status, viewsets
from rest_framework.response import Response
from rest_framework.views import APIView

from .models import Payment
from .serializers import PaymentSerializer


class PaymentViewSet(
    mixins.CreateModelMixin,
    mixins.ListModelMixin,
    mixins.RetrieveModelMixin,
    viewsets.GenericViewSet,
):
    """
    API платежей:

    - GET  /api/payments/       — список платежей текущего пользователя;
    - POST /api/payments/       — начать оплату для брони;
    - GET  /api/payments/{id}/  — детали платежа.

    Только владелец платежа видит свои платежи; админ — все.
    """

    serializer_class = PaymentSerializer
    permission_classes = [permissions.IsAuthenticated]

    def get_queryset(self):
        user = self.request.user
        qs = Payment.objects.select_related(
            "booking",
            "booking__spot",
            "booking__spot__lot",
            "payer",
        )
        if not user.is_authenticated:
            return Payment.objects.none()
        if user.is_superuser:
            return qs
        return qs.filter(payer=user)

    def perform_create(self, serializer: PaymentSerializer) -> None:
        serializer.save()


class YooKassaWebhookView(APIView):
    """
    Обработчик webhook‑уведомлений YooKassa.

    URL: /payments/webhook/yookassa/  (см. backend.config.urls)

    Ожидается JSON вида:

    {
        "event": "payment.succeeded",
        "object": {
            "id": "...",
            "status": "succeeded",
            ...
        }
    }

    Подпись/секрет проверяется по заголовку X-Yookassa-Signature
    (или X-Yookassa-Webhook-Secret), который совпадает с
    settings.YOOKASSA_WEBHOOK_SECRET. Если секрет не задан, проверка
    подписи пропускается.
    """

    authentication_classes: list = []
    permission_classes = [permissions.AllowAny]

    def post(self, request, *args, **kwargs):
        secret_expected = getattr(settings, "YOOKASSA_WEBHOOK_SECRET", "")
        if secret_expected:
            signature = (
                request.headers.get("X-Yookassa-Signature")
                or request.headers.get("X-Yookassa-Webhook-Secret")
            )
            if not signature or signature != secret_expected:
                return Response(
                    {"detail": "Invalid webhook signature"},
                    status=status.HTTP_403_FORBIDDEN,
                )

        data = request.data or {}
        event = data.get("event")
        obj = data.get("object") or {}
        provider_payment_id = obj.get("id")

        if not provider_payment_id:
            return Response(
                {"detail": "Missing payment id"},
                status=status.HTTP_400_BAD_REQUEST,
            )

        try:
            payment = Payment.objects.select_related("booking").get(
                provider_payment_id=provider_payment_id
            )
        except Payment.DoesNotExist:
            return Response(
                {"detail": "Payment not found"},
                status=status.HTTP_404_NOT_FOUND,
            )

        status_from_provider = obj.get("status")
        payment.raw_webhook = data

        if status_from_provider == "succeeded" or event == "payment.succeeded":
            payment.mark_succeeded(webhook_data=data)
        elif status_from_provider in ("canceled", "cancelled") or event == "payment.canceled":
            payment.mark_cancelled(webhook_data=data)
        else:
            # Любые промежуточные статусы считаем ожидающими
            payment.status = Payment.Status.PENDING
            payment.success = False
            payment.failure = False
            payment.save(
                update_fields=["status", "success", "failure", "raw_webhook", "updated_at"]
            )

        return Response({"detail": "ok"}, status=status.HTTP_200_OK)


################################################################################
# File: payments\migrations\0001_initial.py
################################################################################

# Generated by Django 5.2.8 on 2025-11-21 21:34

import django.db.models.deletion
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('parking', '0001_initial'),
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='Payment',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('created_at', models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')),
                ('updated_at', models.DateTimeField(auto_now=True, verbose_name='Дата обновления')),
                ('provider', models.CharField(choices=[('yookassa', 'YooKassa')], default='yookassa', max_length=32, verbose_name='Провайдер')),
                ('provider_payment_id', models.CharField(blank=True, db_index=True, max_length=128, verbose_name='ID платежа у провайдера')),
                ('amount', models.DecimalField(decimal_places=2, max_digits=10, verbose_name='Сумма')),
                ('currency', models.CharField(default='RUB', max_length=8, verbose_name='Валюта')),
                ('status', models.CharField(choices=[('created', 'Создан'), ('pending', 'Ожидает оплаты'), ('succeeded', 'Успешен'), ('cancelled', 'Отменён'), ('failed', 'Ошибка')], db_index=True, default='created', max_length=16, verbose_name='Статус')),
                ('success', models.BooleanField(default=False, verbose_name='Успешен')),
                ('failure', models.BooleanField(default=False, verbose_name='Ошибка')),
                ('raw_response', models.JSONField(blank=True, help_text='Сырые данные, вернувшиеся при создании платежа.', null=True, verbose_name='Ответ провайдера')),
                ('raw_webhook', models.JSONField(blank=True, help_text='Последнее уведомление провайдера по этому платежу.', null=True, verbose_name='Последний webhook')),
                ('booking', models.OneToOneField(on_delete=django.db.models.deletion.CASCADE, related_name='payment', to='parking.booking', verbose_name='Бронь')),
                ('payer', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='payments', to=settings.AUTH_USER_MODEL, verbose_name='Плательщик')),
            ],
            options={
                'verbose_name': 'Платёж',
                'verbose_name_plural': 'Платежи',
                'ordering': ('-created_at',),
            },
        ),
    ]


################################################################################
# File: payments\migrations\__init__.py
################################################################################



################################################################################
# File: payments\providers\__init__.py
################################################################################

from __future__ import annotations

"""
Единая точка входа для работы с YooKassa.

Используется PaymentSerializer через:

    from .providers import YooKassaError, create_yookassa_payment
"""

from .yookassa import YooKassaError, create_yookassa_payment

__all__ = [
    "YooKassaError",
    "create_yookassa_payment",
]


################################################################################
# File: payments\providers\base.py
################################################################################

# payments/providers/base.py

from __future__ import annotations

from abc import ABC, abstractmethod
from typing import Any

from ..models import Payment  # <-- ВАЖНО: относительный импорт, а не backend.payments



class PaymentProvider(ABC):
    """
    Базовый интерфейс платёжного провайдера.
    """

    @abstractmethod
    def create_payment(
        self,
        payment: Payment,
        return_url: str,
        webhook_url: str,
    ) -> Dict[str, Any]:
        """
        Создать платёж у провайдера и вернуть его данные (включая confirmation_url).
        """
        raise NotImplementedError("Метод create_payment должен быть реализован.")

    @abstractmethod
    def handle_webhook(self, request) -> Optional[Payment]:
        """
        Обработать webhook от провайдера и обновить Payment/Booking.
        """
        raise NotImplementedError("Метод handle_webhook должен быть реализован.")

    @abstractmethod
    def refund(self, payment: Payment, amount: Optional[float] = None) -> None:
        """
        Инициировать возврат по платежу.
        """
        raise NotImplementedError("Метод refund должен быть реализован.")


################################################################################
# File: payments\providers\yookassa.py
################################################################################

from __future__ import annotations

import uuid
from decimal import Decimal
from typing import Any, Tuple

from django.conf import settings
from django.core.exceptions import ImproperlyConfigured

try:
    # Официальный синхронный SDK YooKassa
    from yookassa import Configuration, Payment as YooPayment  # type: ignore[import]
except ImportError:  # pragma: no cover - мягкий фолбэк
    Configuration = None
    YooPayment = None


class YooKassaError(Exception):
    """Базовая ошибка при работе с YooKassa."""
    pass


def _configure_yookassa() -> None:
    """
    Настраивает SDK YooKassa из Django settings.

    Требуются:
    - YOOKASSA_SHOP_ID
    - YOOKASSA_SECRET_KEY
    """
    if Configuration is None or YooPayment is None:
        raise ImproperlyConfigured(
            "Пакет 'yookassa' не установлен. Добавьте его в requirements.txt."
        )

    shop_id = getattr(settings, "YOOKASSA_SHOP_ID", "")
    secret_key = getattr(settings, "YOOKASSA_SECRET_KEY", "")
    if not shop_id or not secret_key:
        raise ImproperlyConfigured(
            "Не заданы YOOKASSA_SHOP_ID и/или YOOKASSA_SECRET_KEY в настройках."
        )

    Configuration.account_id = shop_id
    Configuration.secret_key = secret_key


def create_yookassa_payment(booking) -> Tuple[str, str, dict[str, Any]]:
    """
    Создаёт платёж в YooKassa для указанной брони.

    Возвращает:
        (payment_url, provider_payment_id, raw_response_dict)

    Все сетевые вызовы инкапсулированы здесь.
    """
    _configure_yookassa()

    from parking.models import Booking  # локальный импорт, чтобы избежать циклов

    if not isinstance(booking, Booking):
        raise YooKassaError("create_yookassa_payment ожидает экземпляр Booking.")

    amount = booking.total_price
    if not isinstance(amount, Decimal):
        amount = Decimal(str(amount))

    amount_str = str(amount.quantize(Decimal("0.01")))
    currency = booking.currency or "RUB"
    return_url = getattr(settings, "YOOKASSA_RETURN_URL", "")

    description = f"Оплата брони #{booking.id} — {booking.spot}"

    payload: dict[str, Any] = {
        "amount": {
            "value": amount_str,
            "currency": currency,
        },
        "confirmation": {
            "type": "redirect",
            "return_url": return_url,
        },
        "capture": True,
        "description": description,
        "metadata": {
            "booking_id": str(booking.id),
            "user_id": str(booking.user_id),
        },
    }

    try:
        payment = YooPayment.create(payload, uuid.uuid4())
    except Exception as exc:  # noqa: BLE001
        raise YooKassaError(str(exc)) from exc

    confirmation = getattr(payment, "confirmation", None)
    payment_url = getattr(confirmation, "confirmation_url", None) if confirmation else None
    provider_payment_id = getattr(payment, "id", None)

    if not payment_url or not provider_payment_id:
        raise YooKassaError(
            "Некорректный ответ от YooKassa: не получены id или URL оплаты."
        )

    raw_response = {
        "id": provider_payment_id,
        "status": getattr(payment, "status", None),
    }

    return payment_url, provider_payment_id, raw_response


################################################################################
# File: static\manifest.webmanifest
################################################################################

{
  "name": "ParkShare RU — бронирование парковок",
  "short_name": "ParkShare",
  "description": "Поиск и бронирование парковочных мест во дворах, у офисов и рядом с домом.",
  "start_url": "/",
  "scope": "/",
  "display": "standalone",
  "orientation": "portrait-primary",
  "theme_color": "#0d6efd",
  "background_color": "#050816",
  "icons": [
    {
      "src": "/static/icons/icon-72.png",
      "sizes": "72x72",
      "type": "image/png"
    },
    {
      "src": "/static/icons/icon-96.png",
      "sizes": "96x96",
      "type": "image/png"
    },
    {
      "src": "/static/icons/icon-128.png",
      "sizes": "128x128",
      "type": "image/png"
    },
    {
      "src": "/static/icons/icon-192.png",
      "sizes": "192x192",
      "type": "image/png"
    },
    {
      "src": "/static/icons/icon-256.png",
      "sizes": "256x256",
      "type": "image/png"
    },
    {
      "src": "/static/icons/icon-384.png",
      "sizes": "384x384",
      "type": "image/png"
    },
    {
      "src": "/static/icons/icon-512.png",
      "sizes": "512x512",
      "type": "image/png"
    }
  ]
}


################################################################################
# File: static\service-worker.js
################################################################################

/* eslint-disable no-restricted-globals */

const STATIC_CACHE = "parkshare-static-v3";
const DYNAMIC_CACHE = "parkshare-dynamic-v3";
const OFFLINE_URL = "/offline/";

const STATIC_ASSETS = [
  "/",
  "/offline/",
  "/static/css/app.css",
  "/static/js/app.js",
  "/manifest.webmanifest"
  // Иконки попадут в кэш по мере использования браузером
];

function isSameOrigin(request) {
  return new URL(request.url).origin === self.location.origin;
}

self.addEventListener("install", (event) => {
  console.log("[SW] install");

  event.waitUntil(
    caches.open(STATIC_CACHE)
      .then((cache) => cache.addAll(STATIC_ASSETS))
      .then(() => self.skipWaiting())
      .catch((err) => console.warn("[SW] pre-cache error", err))
  );
});

self.addEventListener("activate", (event) => {
  console.log("[SW] activate");

  event.waitUntil(
    caches.keys().then((keys) => {
      return Promise.all(
        keys
          .filter((key) => key !== STATIC_CACHE && key !== DYNAMIC_CACHE)
          .map((key) => {
            console.log("[SW] removing old cache", key);
            return caches.delete(key);
          })
      );
    }).then(() => self.clients.claim())
  );
});

self.addEventListener("fetch", (event) => {
  const { request } = event;

  // Только GET
  if (request.method !== "GET") return;

  const url = new URL(request.url);

  // Не трогаем сторонние домены
  if (!isSameOrigin(request)) return;

  // HTML: network-first с оффлайн-фоллбеком
  if (request.mode === "navigate" || request.headers.get("accept")?.includes("text/html")) {
    event.respondWith(networkFirst(request));
    return;
  }

  // Статика: cache-first
  if (url.pathname.startsWith("/static/")) {
    event.respondWith(cacheFirst(request));
    return;
  }

  // API: network-first с кэшом на всякий случай
  if (url.pathname.startsWith("/api/")) {
    event.respondWith(networkFirst(request));
    return;
  }

  // Всё остальное — мягкий cache-first
  event.respondWith(cacheFirst(request));
});

async function cacheFirst(request) {
  const cached = await caches.match(request);
  if (cached) return cached;

  try {
    const response = await fetch(request);
    const cache = await caches.open(DYNAMIC_CACHE);
    cache.put(request, response.clone());
    return response;
  } catch (err) {
    // В случае ошибки просто пробуем offline.html для HTML-запросов
    if (request.headers.get("accept")?.includes("text/html")) {
      const offline = await caches.match(OFFLINE_URL);
      if (offline) return offline;
    }
    throw err;
  }
}

async function networkFirst(request) {
  try {
    const response = await fetch(request);
    const cache = await caches.open(DYNAMIC_CACHE);
    cache.put(request, response.clone());
    return response;
  } catch (err) {
    const cached = await caches.match(request);
    if (cached) return cached;

    if (request.headers.get("accept")?.includes("text/html")) {
      const offline = await caches.match(OFFLINE_URL);
      if (offline) return offline;
    }
    throw err;
  }
}


################################################################################
# File: static\css\app.css
################################################################################

/* ---------- Design tokens ---------- */

:root {
    --ps-color-bg: #050816;
    --ps-color-bg-elevated: #0b1020;
    --ps-color-surface: #10172a;
    --ps-color-border: rgba(255, 255, 255, 0.06);

    --ps-color-primary: #0d6efd;
    --ps-color-primary-soft: rgba(13, 110, 253, 0.16);
    --ps-color-primary-strong: #0a58ca;
    --ps-color-accent: #22c55e;

    --ps-color-text: #f9fafb;
    --ps-color-text-muted: #9ca3af;
    --ps-color-danger: #ef4444;
    --ps-color-warning: #eab308;
    --ps-color-success: #22c55e;
    --ps-color-neutral: #4b5563;

    --ps-radius-sm: 0.5rem;
    --ps-radius-md: 0.75rem;
    --ps-radius-lg: 1rem;

    --ps-shadow-soft: 0 18px 45px rgba(0, 0, 0, 0.45);
    --ps-shadow-card: 0 10px 30px rgba(15, 23, 42, 0.9);

    --ps-font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text",
    "Segoe UI", sans-serif;

    --ps-transition-fast: 0.15s ease-out;
    --ps-transition-normal: 0.25s ease-out;

    --ps-header-height: 60px;
}

@media (min-width: 768px) {
    :root {
        --ps-header-height: 64px;
    }
}

/* ---------- Reset / base ---------- */

*,
*::before,
*::after {
    box-sizing: border-box;
}

html,
body {
    margin: 0;
    padding: 0;
}

body.ps-body {
    min-height: 100vh;
    font-family: var(--ps-font-family);
    background: radial-gradient(circle at top left, #1d2433 0, #050816 40%, #020617 100%);
    color: var(--ps-color-text);
    -webkit-font-smoothing: antialiased;
}

img {
    max-width: 100%;
    display: block;
}

/* ---------- Layout ---------- */

.ps-header {
    position: sticky;
    top: 0;
    z-index: 40;
    backdrop-filter: blur(12px);
    background: linear-gradient(to bottom, rgba(15, 23, 42, 0.96), rgba(15, 23, 42, 0.7));
    border-bottom: 1px solid rgba(148, 163, 184, 0.18);
}

.ps-navbar {
    max-width: 1120px;
    margin: 0 auto;
    display: flex;
    align-items: center;
    padding: 0.35rem 1rem;
    height: var(--ps-header-height);
}

.ps-navbar-left {
    flex: 1 1 auto;
    display: flex;
    align-items: center;
}

.ps-logo {
    display: inline-flex;
    align-items: baseline;
    gap: 0.24rem;
    text-decoration: none;
}

.ps-logo-main {
    font-weight: 700;
    letter-spacing: 0.03em;
    text-transform: uppercase;
    font-size: 1.05rem;
    color: #f9fafb;
}

.ps-logo-accent {
    font-weight: 700;
    font-size: 0.9rem;
    color: var(--ps-color-primary);
    padding: 0.08rem 0.45rem;
    border-radius: 999px;
    background: linear-gradient(90deg, rgba(59, 130, 246, 0.16), rgba(59, 130, 246, 0.04));
    border: 1px solid rgba(59, 130, 246, 0.4);
}

/* Navbar links + burger */

.ps-navbar-menu {
    display: none;
    flex-direction: column;
    gap: 0.25rem;
    position: absolute;
    inset-inline: 0.75rem;
    top: calc(var(--ps-header-height) + 0.35rem);
    padding: 0.5rem;
    border-radius: var(--ps-radius-md);
    background: rgba(15, 23, 42, 0.97);
    box-shadow: var(--ps-shadow-soft);
    border: 1px solid rgba(148, 163, 184, 0.35);
}

.ps-navbar-menu.is-open {
    display: flex;
}

.ps-nav-link {
    display: inline-flex;
    align-items: center;
    justify-content: flex-start;
    padding: 0.5rem 0.75rem;
    border-radius: 999px;
    font-size: 0.85rem;
    text-decoration: none;
    color: var(--ps-color-text-muted);
    transition: background-color var(--ps-transition-fast), color var(--ps-transition-fast), transform var(--ps-transition-fast);
}

.ps-nav-link:hover {
    background: rgba(15, 23, 42, 0.85);
    color: #e5e7eb;
    transform: translateY(-1px);
}

.ps-nav-link--primary {
    background: linear-gradient(135deg, #2563eb, #0ea5e9);
    color: #eff6ff;
}

.ps-nav-link--primary:hover {
    filter: brightness(1.08);
}

.ps-nav-link--danger {
    color: #fecaca;
}

.ps-nav-link--danger:hover {
    background: rgba(248, 113, 113, 0.08);
}

/* Burger */

.ps-navbar-toggle {
    border: none;
    background: transparent;
    cursor: pointer;
    width: 40px;
    height: 40px;
    border-radius: 999px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    margin-left: auto;
    padding: 0;
}

.ps-navbar-toggle span {
    display: block;
    width: 18px;
    height: 2px;
    border-radius: 999px;
    background: #e5e7eb;
    transition: transform var(--ps-transition-fast), opacity var(--ps-transition-fast), translate var(--ps-transition-fast);
}

.ps-navbar-toggle span + span {
    margin-top: 4px;
}

.ps-navbar-toggle.is-open span:nth-child(1) {
    transform: translateY(6px) rotate(45deg);
}

.ps-navbar-toggle.is-open span:nth-child(2) {
    opacity: 0;
}

.ps-navbar-toggle.is-open span:nth-child(3) {
    transform: translateY(-6px) rotate(-45deg);
}

/* Desktop navbar */

@media (min-width: 768px) {
    .ps-navbar {
        padding-inline: 1.25rem;
    }

    .ps-navbar-menu {
        position: static;
        display: flex !important;
        flex-direction: row;
        gap: 0.35rem;
        padding: 0;
        border-radius: 999px;
        background: transparent;
        box-shadow: none;
        border: none;
    }

    .ps-navbar-toggle {
        display: none;
    }

    .ps-nav-link {
        font-size: 0.85rem;
        padding-inline: 0.9rem;
    }
}

.ps-main {
    max-width: 1120px;
    margin: 1.25rem auto 2.5rem;
    padding-inline: 1rem;
}

@media (min-width: 768px) {
    .ps-main {
        margin-top: 1.8rem;
    }
}

.ps-footer {
    border-top: 1px solid rgba(148, 163, 184, 0.18);
    background: rgba(15, 23, 42, 0.96);
}

.ps-footer-inner {
    max-width: 1120px;
    margin: 0 auto;
    padding: 0.75rem 1rem 1rem;
    display: flex;
    flex-direction: column;
    gap: 0.25rem;
    font-size: 0.8rem;
    color: var(--ps-color-text-muted);
}

@media (min-width: 640px) {
    .ps-footer-inner {
        flex-direction: row;
        justify-content: space-between;
        align-items: center;
    }
}

/* ---------- Sections, grid ---------- */

.ps-section {
    margin-bottom: 2.5rem;
}

.ps-section--flush-top {
    margin-top: 0.5rem;
}

.ps-section--center {
    text-align: center;
    margin-top: 2.5rem;
}

.ps-section--narrow {
    max-width: 640px;
    margin-inline: auto;
}

.ps-section-header {
    margin-bottom: 1.4rem;
}

.ps-section-title {
    margin: 0 0 0.35rem;
    font-size: 1.4rem;
    font-weight: 700;
}

.ps-section-title span {
    color: var(--ps-color-primary);
}

.ps-section-title-sm {
    margin: 0.75rem 0 0.25rem;
    font-size: 1rem;
    font-weight: 600;
}

.ps-section-subtitle {
    margin: 0;
    font-size: 0.9rem;
    color: var(--ps-color-text-muted);
}

.ps-section-subheader {
    margin-top: 1.4rem;
    margin-bottom: 0.5rem;
}

/* Grid */

.ps-grid {
    display: grid;
    gap: 1rem;
}

.ps-grid--gap-md {
    gap: 0.75rem;
}

.ps-grid--gap-xl {
    gap: 1.5rem;
}

.ps-grid--2col {
    grid-template-columns: repeat(2, minmax(0, 1fr));
}

@media (min-width: 992px) {
    .ps-grid--2col@lg {
        grid-template-columns: 1.1fr 1.2fr;
        align-items: flex-start;
    }
}

@media (min-width: 992px) {
    .ps-grid--3col@lg {
        grid-template-columns: minmax(0, 0.9fr) minmax(0, 1.6fr);
    }
}

@media (min-width: 1200px) {
    .ps-grid--3col@xl {
        grid-template-columns: minmax(0, 1.1fr) minmax(0, 1.9fr);
    }
}

.ps-grid-span-1 {
    grid-column: span 1 / span 1;
}

.ps-grid-span-2 {
    grid-column: span 1 / span 1;
}

@media (min-width: 992px) {
    .ps-grid-span-2 {
        grid-column: span 1 / span 1;
    }
}

/* ---------- Hero ---------- */

.ps-hero {
    margin-bottom: 2rem;
}

.ps-hero-inner {
    display: grid;
    gap: 1.75rem;
}

@media (min-width: 768px) {
    .ps-hero-inner {
        grid-template-columns: minmax(0, 1.5fr) minmax(0, 1fr);
        align-items: center;
    }
}

.ps-hero-title {
    margin: 0 0 0.5rem;
    font-size: 1.9rem;
    line-height: 1.2;
}

.ps-hero-title span {
    color: var(--ps-color-primary);
}

@media (min-width: 640px) {
    .ps-hero-title {
        font-size: 2.15rem;
    }
}

.ps-hero-subtitle {
    margin: 0 0 1rem;
    font-size: 0.95rem;
    color: var(--ps-color-text-muted);
}

.ps-hero-actions {
    display: flex;
    flex-wrap: wrap;
    gap: 0.6rem;
    margin-bottom: 0.75rem;
}

.ps-hero-meta {
    font-size: 0.8rem;
    color: var(--ps-color-text-muted);
}

.ps-hero-visual {
    display: flex;
    justify-content: center;
}

.ps-hero-card {
    padding: 0.9rem 1rem;
    border-radius: var(--ps-radius-lg);
    background: radial-gradient(circle at top left, rgba(37, 99, 235, 0.25), rgba(15, 23, 42, 0.95));
    border: 1px solid rgba(148, 163, 184, 0.26);
    box-shadow: var(--ps-shadow-card);
    min-width: 260px;
}

.ps-hero-card-line {
    display: flex;
    align-items: center;
    gap: 0.4rem;
    font-size: 0.85rem;
    color: #e5e7eb;
}

.ps-hero-card-line + .ps-hero-card-line {
    margin-top: 0.4rem;
}

.ps-dot {
    width: 8px;
    height: 8px;
    border-radius: 999px;
}

.ps-dot--green {
    background: var(--ps-color-success);
}

.ps-dot--blue {
    background: var(--ps-color-primary);
}

.ps-dot--yellow {
    background: var(--ps-color-warning);
}

/* ---------- Cards, lists ---------- */

.ps-card {
    border-radius: var(--ps-radius-md);
    background: radial-gradient(circle at top, rgba(15, 23, 42, 0.98), #020617);
    border: 1px solid rgba(148, 163, 184, 0.22);
    padding: 0.9rem 0.95rem;
    box-shadow: 0 10px 35px rgba(15, 23, 42, 0.86);
}

.ps-card--elevated {
    box-shadow: var(--ps-shadow-card);
}

.ps-card-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 0.5rem;
    margin-bottom: 0.6rem;
}

.ps-card-title {
    font-size: 1rem;
    font-weight: 600;
}

.ps-card-body {
    font-size: 0.88rem;
}

.ps-card-line {
    margin-bottom: 0.25rem;
}

.ps-card-line--muted {
    color: var(--ps-color-text-muted);
    font-size: 0.8rem;
}

/* Spot card */

.ps-card--spot {
    margin-bottom: 0.5rem;
}

/* Lists */

.ps-list {
    list-style: none;
    padding: 0;
    margin: 0;
}

.ps-list--compact .ps-list-item {
    padding-block: 0.45rem;
}

.ps-list-item {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 0.5rem;
    padding-block: 0.5rem;
    border-bottom: 1px dashed rgba(148, 163, 184, 0.28);
}

.ps-list-item:last-child {
    border-bottom: none;
}

.ps-list-main {
    min-width: 0;
}

.ps-list-title {
    font-size: 0.9rem;
    font-weight: 500;
}

.ps-list-subtitle {
    font-size: 0.78rem;
    color: var(--ps-color-text-muted);
}

.ps-list-empty {
    font-size: 0.85rem;
    color: var(--ps-color-text-muted);
    padding-block: 0.4rem;
}

/* ---------- Inputs / forms ---------- */

.ps-form {
    display: flex;
    flex-direction: column;
    gap: 0.6rem;
}

.ps-form-row {
    display: flex;
    flex-direction: column;
    gap: 0.2rem;
}

.ps-form-label {
    font-size: 0.82rem;
    color: var(--ps-color-text-muted);
}

.ps-input {
    border-radius: var(--ps-radius-sm);
    border: 1px solid rgba(148, 163, 184, 0.4);
    background: rgba(15, 23, 42, 0.95);
    color: var(--ps-color-text);
    padding: 0.45rem 0.55rem;
    font-size: 0.9rem;
    outline: none;
    transition: border-color var(--ps-transition-fast), box-shadow var(--ps-transition-fast), background-color var(--ps-transition-fast), transform var(--ps-transition-fast);
}

.ps-input:focus {
    border-color: var(--ps-color-primary);
    box-shadow: 0 0 0 1px rgba(37, 99, 235, 0.35);
    transform: translateY(-0.5px);
}

.ps-field-error {
    font-size: 0.75rem;
    color: #fecaca;
}

.ps-field-help {
    font-size: 0.75rem;
    color: var(--ps-color-text-muted);
}

.ps-form-actions {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    margin-top: 0.4rem;
}

@media (min-width: 640px) {
    .ps-form-actions {
        flex-direction: row;
        justify-content: flex-start;
    }
}

/* ---------- Buttons ---------- */

.ps-btn {
    border-radius: 999px;
    border: none;
    padding: 0.45rem 0.95rem;
    font-size: 0.88rem;
    font-weight: 500;
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: 0.35rem;
    background: linear-gradient(135deg, #2563eb, #0ea5e9);
    color: #eff6ff;
    text-decoration: none;
    transition: transform var(--ps-transition-fast), box-shadow var(--ps-transition-fast), filter var(--ps-transition-fast), background var(--ps-transition-fast);
}

.ps-btn:hover {
    transform: translateY(-1px);
    filter: brightness(1.06);
    box-shadow: 0 14px 32px rgba(37, 99, 235, 0.6);
}

.ps-btn:active {
    transform: translateY(1px);
    box-shadow: 0 8px 20px rgba(15, 23, 42, 0.8);
}

.ps-btn-secondary {
    background: rgba(15, 23, 42, 0.96);
    color: #e5e7eb;
    border: 1px solid rgba(148, 163, 184, 0.5);
    box-shadow: none;
}

.ps-btn-secondary:hover {
    background: rgba(15, 23, 42, 1);
    border-color: rgba(148, 163, 184, 0.8);
}

.ps-btn-ghost {
    background: transparent;
    color: #e5e7eb;
    border: 1px solid rgba(148, 163, 184, 0.35);
}

.ps-btn-ghost:hover {
    background: rgba(15, 23, 42, 0.8);
}

.ps-btn-lg {
    padding-block: 0.55rem;
    padding-inline: 1.1rem;
}

.ps-btn-full {
    width: 100%;
}

/* ---------- Badges ---------- */

.ps-badge {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    padding: 0.15rem 0.55rem;
    border-radius: 999px;
    font-size: 0.72rem;
    font-weight: 500;
    border: 1px solid transparent;
}

.ps-badge--success {
    background: rgba(34, 197, 94, 0.1);
    border-color: rgba(34, 197, 94, 0.65);
    color: #bbf7d0;
}

.ps-badge--neutral {
    background: rgba(148, 163, 184, 0.12);
    border-color: rgba(148, 163, 184, 0.6);
    color: #e5e7eb;
}

/* Статусные бейджи по Booking.status / Spot.status */

.ps-badge--status-pending {
    background: rgba(234, 179, 8, 0.1);
    border-color: rgba(234, 179, 8, 0.7);
    color: #facc15;
}

.ps-badge--status-confirmed,
.ps-badge--status-active {
    background: rgba(34, 197, 94, 0.1);
    border-color: rgba(34, 197, 94, 0.7);
    color: #bbf7d0;
}

.ps-badge--status-completed {
    background: rgba(59, 130, 246, 0.1);
    border-color: rgba(59, 130, 246, 0.7);
    color: #bfdbfe;
}

.ps-badge--status-cancelled,
.ps-badge--status-expired,
.ps-badge--status-inactive {
    background: rgba(248, 113, 113, 0.08);
    border-color: rgba(248, 113, 113, 0.7);
    color: #fecaca;
}

/* ---------- Tables ---------- */

.ps-table-wrapper {
    overflow-x: auto;
    margin-top: 0.3rem;
}

.ps-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 0.85rem;
}

.ps-table thead {
    background: rgba(15, 23, 42, 0.95);
}

.ps-table th,
.ps-table td {
    padding: 0.45rem 0.5rem;
    border-bottom: 1px solid rgba(30, 64, 175, 0.45);
}

.ps-table th {
    text-align: left;
    font-weight: 500;
    font-size: 0.78rem;
    color: var(--ps-color-text-muted);
}

.ps-table tbody tr:nth-child(even) {
    background: rgba(15, 23, 42, 0.75);
}

.ps-table tbody tr:hover {
    background: rgba(30, 64, 175, 0.45);
}

/* Mobile table labels */

@media (max-width: 640px) {
    .ps-table thead {
        display: none;
    }

    .ps-table tr {
        display: grid;
        padding-block: 0.4rem;
        border-bottom: 1px solid rgba(30, 64, 175, 0.45);
    }

    .ps-table td {
        border: none;
        padding: 0.2rem 0.3rem;
    }

    .ps-table td::before {
        content: attr(data-label);
        display: inline-block;
        width: 46%;
        max-width: 120px;
        font-size: 0.74rem;
        text-transform: uppercase;
        letter-spacing: 0.04em;
        color: var(--ps-color-text-muted);
    }

    .ps-table td {
        font-size: 0.8rem;
    }
}

/* ---------- Map ---------- */

.ps-map {
    border-radius: var(--ps-radius-md);
    border: 1px solid rgba(148, 163, 184, 0.3);
    overflow: hidden;
    height: 260px;
    margin-bottom: 0.75rem;
    box-shadow: var(--ps-shadow-card);
}

@media (min-width: 768px) {
    .ps-map {
        height: 320px;
    }
}

/* ---------- Skeleton loading ---------- */

.ps-card--skeleton {
    position: relative;
    overflow: hidden;
}

.ps-skeleton-line {
    height: 0.55rem;
    border-radius: 999px;
    background: linear-gradient(
            90deg,
            rgba(31, 41, 55, 0.9),
            rgba(55, 65, 81, 0.85),
            rgba(31, 41, 55, 0.9)
    );
    background-size: 200% 100%;
    animation: ps-shimmer 1.2s linear infinite;
    margin-bottom: 0.3rem;
}

.ps-skeleton-line--lg {
    width: 75%;
}

.ps-skeleton-line--short {
    width: 40%;
}

@keyframes ps-shimmer {
    0% {
        background-position: 200% 0;
    }
    100% {
        background-position: -200% 0;
    }
}

/* ---------- Empty state / hints ---------- */

.ps-empty {
    font-size: 0.85rem;
    color: var(--ps-color-text-muted);
    padding: 0.4rem 0;
}

.ps-hint {
    font-size: 0.82rem;
    color: var(--ps-color-text-muted);
}

/* ---------- Back to top ---------- */

.ps-back-to-top {
    position: fixed;
    right: 1rem;
    bottom: 1.1rem;
    width: 38px;
    height: 38px;
    border-radius: 999px;
    border: 1px solid rgba(148, 163, 184, 0.6);
    background: radial-gradient(circle at top, rgba(30, 64, 175, 0.7), rgba(15, 23, 42, 0.98));
    color: #e5e7eb;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    opacity: 0;
    pointer-events: none;
    transform: translateY(8px);
    transition: opacity var(--ps-transition-normal), transform var(--ps-transition-normal), box-shadow var(--ps-transition-fast);
    box-shadow: 0 10px 30px rgba(15, 23, 42, 0.9);
    z-index: 50;
}

.ps-back-to-top.is-visible {
    opacity: 1;
    pointer-events: auto;
    transform: translateY(0);
}

.ps-back-to-top:hover {
    box-shadow: 0 18px 40px rgba(15, 23, 42, 0.95);
}

/* ---------- Toasts ---------- */

.ps-toast-container {
    position: fixed;
    inset-inline: 0;
    bottom: 0.85rem;
    display: flex;
    flex-direction: column;
    gap: 0.4rem;
    padding-inline: 0.75rem;
    z-index: 60;
}

@media (min-width: 640px) {
    .ps-toast-container {
        align-items: center;
    }
}

.ps-toast {
    max-width: 360px;
    width: 100%;
    border-radius: var(--ps-radius-md);
    padding: 0.6rem 0.75rem;
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 0.5rem;
    font-size: 0.82rem;
    border: 1px solid rgba(148, 163, 184, 0.56);
    background: rgba(15, 23, 42, 0.98);
    box-shadow: var(--ps-shadow-card);
    transform: translateY(8px);
    opacity: 0;
    animation: ps-toast-in 0.22s ease-out forwards;
}

.ps-toast-message {
    flex: 1;
}

.ps-toast-close {
    border: none;
    background: transparent;
    color: var(--ps-color-text-muted);
    cursor: pointer;
    padding: 0.1rem;
    font-size: 1rem;
}

.ps-toast--success {
    border-color: rgba(34, 197, 94, 0.7);
}

.ps-toast--error {
    border-color: rgba(248, 113, 113, 0.8);
}

@keyframes ps-toast-in {
    from {
        opacity: 0;
        transform: translateY(8px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

/* ---------- Install banner ---------- */

.ps-install-banner {
    position: fixed;
    inset-inline: 0.5rem;
    bottom: 4rem;
    z-index: 55;
    display: flex;
    justify-content: center;
}

.ps-install-banner-inner {
    max-width: 420px;
    width: 100%;
    border-radius: var(--ps-radius-lg);
    padding: 0.6rem 0.75rem;
    background: radial-gradient(circle at top left, rgba(37, 99, 235, 0.3), rgba(15, 23, 42, 0.98));
    border: 1px solid rgba(148, 163, 184, 0.65);
    box-shadow: var(--ps-shadow-card);
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    font-size: 0.82rem;
}

.ps-install-banner-actions {
    display: flex;
    flex-wrap: wrap;
    gap: 0.4rem;
}

/* ---------- Auth ---------- */

.ps-auth {
    min-height: calc(100vh - var(--ps-header-height) - 80px);
    display: flex;
    align-items: center;
    justify-content: center;
}

.ps-auth-card {
    max-width: 420px;
    width: 100%;
}

.ps-auth-title {
    margin: 0 0 0.4rem;
    font-size: 1.4rem;
}

.ps-auth-subtitle {
    margin: 0 0 1rem;
    font-size: 0.9rem;
    color: var(--ps-color-text-muted);
}

.ps-auth-footer {
    margin-top: 0.75rem;
    font-size: 0.8rem;
    color: var(--ps-color-text-muted);
}

.ps-auth-footer a {
    color: var(--ps-color-primary);
    text-decoration: none;
}

.ps-auth-footer a:hover {
    text-decoration: underline;
}

/* ---------- Alerts ---------- */

.ps-alert {
    border-radius: var(--ps-radius-sm);
    padding: 0.4rem 0.55rem;
    font-size: 0.8rem;
    margin-bottom: 0.45rem;
}

.ps-alert--danger {
    background: rgba(248, 113, 113, 0.12);
    border: 1px solid rgba(248, 113, 113, 0.7);
    color: #fecaca;
}

/* ---------- Offline ---------- */

.ps-offline-icon {
    font-size: 2.5rem;
    margin-bottom: 0.75rem;
}

.ps-offline-actions {
    margin-top: 1rem;
    display: flex;
    justify-content: center;
    gap: 0.5rem;
    flex-wrap: wrap;
}

/* ---------- Animations & micro-interactions ---------- */

.ps-animate-fade-up {
    opacity: 0;
    transform: translateY(8px);
    animation: ps-fade-up 0.45s ease-out forwards;
}

.ps-animate-delay-1 {
    animation-delay: 0.12s;
}

.ps-animate-stagger {
    animation-delay: 0.04s;
}

.ps-animate-float {
    animation: ps-float 6s ease-in-out infinite;
}

@keyframes ps-fade-up {
    from {
        opacity: 0;
        transform: translateY(8px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

@keyframes ps-float {
    0% {
        transform: translateY(0);
    }
    50% {
        transform: translateY(-6px);
    }
    100% {
        transform: translateY(0);
    }
}

.ps-form-row input,
.ps-form-row select,
.ps-form-row textarea {
    /* всё то, что ты хотел для .ps-input */
    border-radius: 8px;
    padding: 0.75rem 1rem;
    /* и т.д. */
}


################################################################################
# File: static\js\app.js
################################################################################

(function () {
    "use strict";

    // ---------- Helpers ----------

    function qs(selector, scope) {
        return (scope || document).querySelector(selector);
    }

    function qsa(selector, scope) {
        return Array.prototype.slice.call((scope || document).querySelectorAll(selector));
    }

    // ---------- Service worker ----------

    if ("serviceWorker" in navigator) {
        window.addEventListener("load", function () {
            navigator.serviceWorker
                .register("/service-worker.js")
                .then(function (reg) {
                    console.log("[SW] registered", reg.scope);
                })
                .catch(function (err) {
                    console.warn("[SW] registration failed", err);
                });
        });
    }

    // ---------- Mobile menu ----------

    function initMenu() {
        const toggle = qs("[data-menu-toggle]");
        const menu = qs("[data-menu]");

        if (!toggle || !menu) return;

        toggle.addEventListener("click", function () {
            const isOpen = toggle.classList.toggle("is-open");
            menu.classList.toggle("is-open", isOpen);
        });

        // закрывать по клику на ссылку (на мобиле)
        qsa(".ps-nav-link", menu).forEach(function (link) {
            link.addEventListener("click", function () {
                toggle.classList.remove("is-open");
                menu.classList.remove("is-open");
            });
        });
    }

    // ---------- Smooth scroll ----------

    function initSmoothScroll() {
        qsa("[data-scroll-to]").forEach(function (el) {
            el.addEventListener("click", function (e) {
                const href = el.getAttribute("href");
                if (!href || !href.startsWith("#")) return;
                const target = qs(href);
                if (!target) return;
                e.preventDefault();
                window.scrollTo({
                    top: target.getBoundingClientRect().top + window.scrollY - 72,
                    behavior: "smooth"
                });
            });
        });
    }

    // ---------- Back to top ----------

    function initBackToTop() {
        const btn = qs("[data-back-to-top]");
        if (!btn) return;

        function onScroll() {
            if (window.scrollY > 300) {
                btn.classList.add("is-visible");
            } else {
                btn.classList.remove("is-visible");
            }
        }

        window.addEventListener("scroll", onScroll, {passive: true});
        onScroll();

        btn.addEventListener("click", function () {
            window.scrollTo({top: 0, behavior: "smooth"});
        });
    }

    // ---------- Toasts ----------

    function showToast(message, type) {
        type = type || "info";
        const container = qs(".ps-toast-container");
        if (!container) return;

        const toast = document.createElement("div");
        toast.className = "ps-toast ps-toast--" + type;

        const msg = document.createElement("div");
        msg.className = "ps-toast-message";
        msg.textContent = message;

        const close = document.createElement("button");
        close.className = "ps-toast-close";
        close.type = "button";
        close.innerHTML = "×";

        close.addEventListener("click", function () {
            toast.remove();
        });

        toast.appendChild(msg);
        toast.appendChild(close);
        container.appendChild(toast);

        setTimeout(function () {
            toast.remove();
        }, 4000);
    }

    // ---------- PWA install banner ----------

    let deferredPrompt = null;

    function initInstallBanner() {
        const banner = qs("[data-install-banner]");
        const btnAccept = qs("[data-install-accept]", banner);
        const btnDismiss = qs("[data-install-dismiss]", banner);

        if (!banner || !btnAccept || !btnDismiss) return;

        window.addEventListener("beforeinstallprompt", function (e) {
            e.preventDefault();
            deferredPrompt = e;
            banner.hidden = false;
        });

        btnDismiss.addEventListener("click", function () {
            banner.hidden = true;
            deferredPrompt = null;
        });

        btnAccept.addEventListener("click", function () {
            if (!deferredPrompt) {
                banner.hidden = true;
                return;
            }
            deferredPrompt.prompt();
            deferredPrompt.userChoice
                .then(function (choiceResult) {
                    if (choiceResult.outcome === "accepted") {
                        showToast("Установка ParkShare RU запущена", "success");
                    }
                    banner.hidden = true;
                    deferredPrompt = null;
                })
                .catch(function () {
                    banner.hidden = true;
                    deferredPrompt = null;
                });
        });
    }

    // ---------- Skeleton removal ----------

    function initSkeletons() {
        const cards = qsa(".ps-card--skeleton");
        if (!cards.length) return;

        // Имитация загрузки данных — через небольшой таймаут
        window.setTimeout(function () {
            cards.forEach(function (card) {
                card.parentNode && card.parentNode.removeChild(card);
            });
        }, 350);
    }

    // ---------- Geolocation helper ----------

    function initGeolocation() {
        const buttons = qsa("[data-fill-location]");
        if (!buttons.length) return;

        function fill(lat, lng) {
            const latInput = qs("#lat");
            const lngInput = qs("#lng");
            if (!latInput || !lngInput) return;
            latInput.value = lat.toFixed(5);
            lngInput.value = lng.toFixed(5);
            showToast("Координаты определены, нажмите «Найти места»", "success");
        }

        buttons.forEach(function (btn) {
            btn.addEventListener("click", function () {
                if (!("geolocation" in navigator)) {
                    showToast("Геолокация недоступна в этом браузере", "error");
                    return;
                }

                navigator.geolocation.getCurrentPosition(
                    function (pos) {
                        fill(pos.coords.latitude, pos.coords.longitude);
                    },
                    function () {
                        showToast("Не удалось получить местоположение", "error");
                    },
                    {
                        enableHighAccuracy: false,
                        timeout: 8000,
                        maximumAge: 60000
                    }
                );
            });
        });
    }

    // ---------- Init ----------

    document.addEventListener("DOMContentLoaded", function () {
        initMenu();
        initSmoothScroll();
        initBackToTop();
        initInstallBanner();
        initSkeletons();
        initGeolocation();
    });

    // Экспортируем showToast в глобальную область на всякий
    window.ParkShare = window.ParkShare || {};
    window.ParkShare.showToast = showToast;
})();


################################################################################
# File: templates\base.html
################################################################################

{% load static %}
<!doctype html>
<html lang="ru">
<head>
    <meta charset="utf-8">
    <title>{% block title %}ParkShare RU{% endblock %}</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- PWA -->
    <meta name="theme-color" content="#0d6efd">
    <link rel="manifest" href="{% url 'manifest' %}">
    <link rel="apple-touch-icon" sizes="192x192" href="{% static 'icons/icon-192.png' %}">
    <link rel="apple-touch-icon" sizes="512x512" href="{% static 'icons/icon-512.png' %}">

    <!-- Favicon (минимальный набор) -->
    <link rel="icon" type="image/png" sizes="32x32" href="{% static 'icons/icon-72.png' %}">

    <!-- Основные стили PWA -->
    <link rel="stylesheet" href="{% static 'css/app.css' %}">

    {% block extra_head %}{% endblock %}
</head>
<body class="ps-body">
<header class="ps-header">
    <nav class="ps-navbar">
        <div class="ps-navbar-left">
            <a href="{% url 'landing' %}" class="ps-logo">
                <span class="ps-logo-main">ParkShare</span><span class="ps-logo-accent">RU</span>
            </a>
        </div>

        <button class="ps-navbar-toggle" type="button" data-menu-toggle aria-label="Открыть меню">
            <span></span>
            <span></span>
            <span></span>
        </button>

        <div class="ps-navbar-menu" data-menu>
            <a href="{% url 'landing' %}" class="ps-nav-link">Главная</a>
            <a href="{% url 'user_dashboard' %}" class="ps-nav-link">Моя парковка</a>
            {% if user.is_authenticated and user.is_owner %}
                <a href="{% url 'owner_dashboard' %}" class="ps-nav-link">Кабинет владельца</a>
            {% endif %}
            {% if user.is_authenticated %}
                <a href="{% url 'accounts:profile' %}" class="ps-nav-link">Профиль</a>
                <a href="{% url 'accounts:logout' %}" class="ps-nav-link ps-nav-link--danger">Выйти</a>
            {% else %}
                <a href="{% url 'accounts:login' %}" class="ps-nav-link">Войти</a>
                <a href="{% url 'accounts:register' %}" class="ps-nav-link ps-nav-link--primary">Регистрация</a>
            {% endif %}
        </div>
    </nav>
</header>

<main class="ps-main">
    {% block content %}{% endblock %}
</main>

<footer class="ps-footer">
    <div class="ps-footer-inner">
        <span>© {% now "Y" %} ParkShare RU</span>
        <span class="ps-footer-meta">PWA · Оффлайн · Быстрая загрузка</span>
    </div>
</footer>

<!-- Back to top -->
<button class="ps-back-to-top" type="button" data-back-to-top aria-label="Наверх">
    ↑
</button>

<!-- Toasts -->
<div class="ps-toast-container" aria-live="polite" aria-atomic="true"></div>

<!-- PWA install banner -->
<div class="ps-install-banner" data-install-banner hidden>
    <div class="ps-install-banner-inner">
        <div class="ps-install-banner-text">
            Установите <strong>ParkShare RU</strong> как приложение
        </div>
        <div class="ps-install-banner-actions">
            <button type="button" class="ps-btn ps-btn-secondary" data-install-dismiss>Позже</button>
            <button type="button" class="ps-btn" data-install-accept>Установить</button>
        </div>
    </div>
</div>

<script src="{% static 'js/app.js' %}"></script>
{% block extra_scripts %}{% endblock %}
</body>
</html>


################################################################################
# File: templates\offline.html
################################################################################

{% extends "base.html" %}

{% block title %}Оффлайн — ParkShare RU{% endblock %}

{% block content %}
<section class="ps-section ps-section--center">
    <div class="ps-offline-icon">☁️</div>
    <h1 class="ps-section-title">Нет подключения к сети</h1>
    <p class="ps-section-subtitle">
        Вы оффлайн. Некоторые данные могут быть устаревшими или недоступными,
        но базовые страницы и ранее открытые ресурсы всё ещё работают.
    </p>
    <div class="ps-offline-actions">
        <button type="button" class="ps-btn" onclick="location.reload()">
            Повторить попытку
        </button>
        <a href="{% url 'landing' %}" class="ps-btn ps-btn-secondary">
            На главную
        </a>
    </div>
</section>
{% endblock %}


################################################################################
# File: templates\accounts\login.html
################################################################################

{% extends "base.html" %}
{% load static %}

{% block title %}Вход — ParkShare RU{% endblock %}

{% block content %}
<section class="ps-auth">
    <div class="ps-auth-card ps-card ps-card--elevated ps-animate-fade-up">
        <h1 class="ps-auth-title">Вход</h1>
        <p class="ps-auth-subtitle">
            Войдите, чтобы управлять своими бронированиями и машинами.
        </p>

        <form method="post" class="ps-form">
            {% csrf_token %}
            {% if form.non_field_errors %}
                <div class="ps-alert ps-alert--danger">
                    {{ form.non_field_errors }}
                </div>
            {% endif %}

            {% for field in form.visible_fields %}
                <div class="ps-form-row">
                    <label class="ps-form-label" for="{{ field.id_for_label }}">
                        {{ field.label }}
                    </label>

                    {{ field }}


                    {% if field.help_text %}
                        <div class="ps-field-help">{{ field.help_text }}</div>
                    {% endif %}
                    {% for error in field.errors %}
                        <div class="ps-field-error">{{ error }}</div>
                    {% endfor %}
                </div>
            {% endfor %}

            <div class="ps-form-actions">
                <button type="submit" class="ps-btn ps-btn-full">
                    Войти
                </button>
            </div>
        </form>

        <div class="ps-auth-footer">
            Нет аккаунта?
            <a href="{% url 'accounts:register' %}">Зарегистрироваться</a>
            <br>
            <a href="{% url 'accounts:password_reset' %}">Забыли пароль?</a>
        </div>
    </div>
</section>
{% endblock %}


################################################################################
# File: templates\accounts\password_change.html
################################################################################

{% extends "base.html" %}

{% block title %}Смена пароля — ParkShare RU{% endblock %}

{% block content %}
<section class="ps-auth">
    <div class="ps-auth-card ps-card ps-card--elevated ps-animate-fade-up">
        <h1 class="ps-auth-title">Смена пароля</h1>
        <p class="ps-auth-subtitle">
            Укажите текущий пароль и новый — мы проверим его надёжность.
        </p>

        <form method="post" class="ps-form">
            {% csrf_token %}
            {% if form.non_field_errors %}
                <div class="ps-alert ps-alert--danger">
                    {{ form.non_field_errors }}
                </div>
            {% endif %}

            {% for field in form.visible_fields %}
                <div class="ps-form-row">
                    <label class="ps-form-label" for="{{ field.id_for_label }}">
                        {{ field.label }}
                    </label>
                    {{ field }}
                    {% if field.help_text %}
                        <div class="ps-field-help">{{ field.help_text }}</div>
                    {% endif %}
                    {% for error in field.errors %}
                        <div class="ps-field-error">{{ error }}</div>
                    {% endfor %}
                </div>
            {% endfor %}

            <div class="ps-form-actions">
                <button type="submit" class="ps-btn ps-btn-full">
                    Обновить пароль
                </button>
            </div>
        </form>
    </div>
</section>
{% endblock %}


################################################################################
# File: templates\accounts\password_change_done.html
################################################################################

{% extends "base.html" %}

{% block title %}Пароль обновлён — ParkShare RU{% endblock %}

{% block content %}
<section class="ps-section ps-section--center ps-section--narrow ps-animate-fade-up">
    <h1 class="ps-section-title">Пароль успешно обновлён</h1>
    <p class="ps-section-subtitle">
        Ваш новый пароль сохранён. Используйте его для следующего входа.
    </p>
    <div class="ps-offline-actions">
        <a href="{% url 'user_dashboard' %}" class="ps-btn">
            В личный кабинет
        </a>
    </div>
</section>
{% endblock %}


################################################################################
# File: templates\accounts\password_reset.html
################################################################################

{% extends "base.html" %}

{% block title %}Сброс пароля — ParkShare RU{% endblock %}

{% block content %}
<section class="ps-auth">
    <div class="ps-auth-card ps-card ps-card--elevated ps-animate-fade-up">
        <h1 class="ps-auth-title">Сброс пароля</h1>
        <p class="ps-auth-subtitle">
            Укажите email, на который зарегистрирован аккаунт. Мы отправим ссылку
            для задания нового пароля.
        </p>

        <form method="post" class="ps-form">
            {% csrf_token %}
            {% if form.non_field_errors %}
                <div class="ps-alert ps-alert--danger">
                    {{ form.non_field_errors }}
                </div>
            {% endif %}

            {% for field in form.visible_fields %}
                <div class="ps-form-row">
                    <label class="ps-form-label" for="{{ field.id_for_label }}">
                        {{ field.label }}
                    </label>
                    {{ field }}
                    {% for error in field.errors %}
                        <div class="ps-field-error">{{ error }}</div>
                    {% endfor %}
                </div>
            {% endfor %}

            <div class="ps-form-actions">
                <button type="submit" class="ps-btn ps-btn-full">
                    Отправить ссылку
                </button>
            </div>
        </form>

        <div class="ps-auth-footer">
            Вспомнили пароль?
            <a href="{% url 'accounts:login' %}">Вернуться ко входу</a>
        </div>
    </div>
</section>
{% endblock %}


################################################################################
# File: templates\accounts\password_reset_complete.html
################################################################################

{% extends "base.html" %}

{% block title %}Пароль изменён — ParkShare RU{% endblock %}

{% block content %}
<section class="ps-section ps-section--center ps-section--narrow ps-animate-fade-up">
    <h1 class="ps-section-title">Пароль успешно изменён</h1>
    <p class="ps-section-subtitle">
        Теперь вы можете войти в свой аккаунт, используя новый пароль.
    </p>
    <div class="ps-offline-actions">
        <a href="{% url 'accounts:login' %}" class="ps-btn">
            Перейти ко входу
        </a>
    </div>
</section>
{% endblock %}


################################################################################
# File: templates\accounts\password_reset_confirm.html
################################################################################

{% extends "base.html" %}

{% block title %}Новый пароль — ParkShare RU{% endblock %}

{% block content %}
<section class="ps-auth">
    <div class="ps-auth-card ps-card ps-card--elevated ps-animate-fade-up">
        {% if validlink %}
            <h1 class="ps-auth-title">Задайте новый пароль</h1>
            <p class="ps-auth-subtitle">
                Введите новый пароль дважды, чтобы исключить опечатки.
            </p>

            <form method="post" class="ps-form">
                {% csrf_token %}
                {% if form.non_field_errors %}
                    <div class="ps-alert ps-alert--danger">
                        {{ form.non_field_errors }}
                    </div>
                {% endif %}

                {% for field in form.visible_fields %}
                    <div class="ps-form-row">
                        <label class="ps-form-label" for="{{ field.id_for_label }}">
                            {{ field.label }}
                        </label>
                        {{ field }}
                        {% if field.help_text %}
                            <div class="ps-field-help">{{ field.help_text }}</div>
                        {% endif %}
                        {% for error in field.errors %}
                            <div class="ps-field-error">{{ error }}</div>
                        {% endfor %}
                    </div>
                {% endfor %}

                <div class="ps-form-actions">
                    <button type="submit" class="ps-btn ps-btn-full">
                        Сохранить новый пароль
                    </button>
                </div>
            </form>
        {% else %}
            <h1 class="ps-auth-title">Ссылка недействительна</h1>
            <p class="ps-auth-subtitle">
                Ссылка для сброса пароля устарела или уже была использована.
                Попробуйте запросить сброс ещё раз.
            </p>
            <div class="ps-offline-actions">
                <a href="{% url 'accounts:password_reset' %}" class="ps-btn">
                    Запросить новую ссылку
                </a>
            </div>
        {% endif %}
    </div>
</section>
{% endblock %}


################################################################################
# File: templates\accounts\password_reset_done.html
################################################################################

{% extends "base.html" %}

{% block title %}Письмо отправлено — ParkShare RU{% endblock %}

{% block content %}
<section class="ps-section ps-section--center ps-section--narrow ps-animate-fade-up">
    <h1 class="ps-section-title">Проверьте почту</h1>
    <p class="ps-section-subtitle">
        Если аккаунт с таким email существует, мы отправили на него письмо
        с дальнейшими инструкциями.
    </p>
    <div class="ps-offline-actions">
        <a href="{% url 'accounts:login' %}" class="ps-btn ps-btn-secondary">
            Вернуться ко входу
        </a>
    </div>
</section>
{% endblock %}


################################################################################
# File: templates\accounts\password_reset_email.txt
################################################################################

Вы получили это письмо, потому что на сайте {{ site_name }} был запрошен сброс пароля
для пользователя, использующего этот email.

Чтобы задать новый пароль, перейдите по ссылке:

{{ protocol }}://{{ domain }}{% url 'accounts:password_reset_confirm' uidb64=uid token=token %}

Если вы не запрашивали сброс пароля, просто проигнорируйте это письмо.


################################################################################
# File: templates\accounts\password_reset_subject.txt
################################################################################

Сброс пароля на ParkShare RU


################################################################################
# File: templates\accounts\profile.html
################################################################################

{% extends "base.html" %}
{% load static %}

{% block title %}Профиль — ParkShare RU{% endblock %}

{% block content %}
<section class="ps-section ps-section--narrow">
    <div class="ps-section-header">
        <h1 class="ps-section-title">Профиль</h1>
        <p class="ps-section-subtitle">
            Обновите контактные данные, чтобы получать уведомления по бронированиям.
        </p>
    </div>

    <div class="ps-card ps-card--elevated ps-animate-fade-up">
        <form method="post" class="ps-form">
            {% csrf_token %}
            {% if form.non_field_errors %}
                <div class="ps-alert ps-alert--danger">
                    {{ form.non_field_errors }}
                </div>
            {% endif %}

            {% for field in form.visible_fields %}
                <div class="ps-form-row">
                    <label class="ps-form-label" for="{{ field.id_for_label }}">
                        {{ field.label }}
                    </label>
                    {{ field }}
                    {% if field.help_text %}
                        <div class="ps-field-help">{{ field.help_text }}</div>
                    {% endif %}
                    {% for error in field.errors %}
                        <div class="ps-field-error">{{ error }}</div>
                    {% endfor %}
                </div>
            {% endfor %}

            <div class="ps-form-actions">
                <button type="submit" class="ps-btn ps-btn-full">
                    Сохранить изменения
                </button>
                <a href="{% url 'user_dashboard' %}" class="ps-btn ps-btn-secondary ps-btn-full">
                    Вернуться в кабинет
                </a>
            </div>
        </form>
    </div>
</section>
{% endblock %}


################################################################################
# File: templates\accounts\register.html
################################################################################

{% extends "base.html" %}
{% load static %}

{% block title %}Регистрация — ParkShare RU{% endblock %}

{% block content %}
<section class="ps-auth">
    <div class="ps-auth-card ps-card ps-card--elevated ps-animate-fade-up">
        <h1 class="ps-auth-title">Регистрация</h1>
        <p class="ps-auth-subtitle">
            Создайте аккаунт, чтобы бронировать парковки и управлять местами.
        </p>

        <form method="post" class="ps-form">
            {% csrf_token %}
            {% if form.non_field_errors %}
                <div class="ps-alert ps-alert--danger">
                    {{ form.non_field_errors }}
                </div>
            {% endif %}

            {% for field in form.visible_fields %}
                <div class="ps-form-row">
                    <label class="ps-form-label" for="{{ field.id_for_label }}">
                        {{ field.label }}
                    </label>
                    {{ field }}
                    {% if field.help_text %}
                        <div class="ps-field-help">{{ field.help_text }}</div>
                    {% endif %}
                    {% for error in field.errors %}
                        <div class="ps-field-error">{{ error }}</div>
                    {% endfor %}
                </div>
            {% endfor %}

            <div class="ps-form-actions">
                <button type="submit" class="ps-btn ps-btn-full">
                    Зарегистрироваться
                </button>
            </div>
        </form>

        <div class="ps-auth-footer">
            Уже есть аккаунт?
            <a href="{% url 'accounts:login' %}">Войти</a>
        </div>
    </div>
</section>
{% endblock %}


################################################################################
# File: templates\parking\landing.html
################################################################################

{% extends "base.html" %}
{% load static %}

{% block title %}ParkShare RU — найти парковку рядом{% endblock %}

{% block extra_head %}
    <!-- Карта (можно переключиться на свои тайлы позже) -->
    <link rel="stylesheet"
          href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
          crossorigin=""/>
{% endblock %}

{% block content %}
<section class="ps-hero ps-animate-fade-up">
    <div class="ps-hero-inner">
        <div class="ps-hero-text">
            <h1 class="ps-hero-title">
                Парковка <span>в один тап</span>
            </h1>
            <p class="ps-hero-subtitle">
                Найдите свободное место во дворе, у офиса или рядом с домом.
                Бронирование, оплата и навигация — прямо в вашем браузере.
            </p>
            <div class="ps-hero-actions">
                <a href="#search" class="ps-btn ps-btn-lg" data-scroll-to>
                    Найти парковку рядом
                </a>
                <button type="button" class="ps-btn ps-btn-ghost ps-btn-lg" data-fill-location>
                    Определить моё местоположение
                </button>
            </div>
            <div class="ps-hero-meta">
                Работает как приложение · Оффлайн-режим · Уведомления о бронях
            </div>
        </div>
        <div class="ps-hero-visual">
            <div class="ps-hero-card ps-animate-float">
                <div class="ps-hero-card-line">
                    <span class="ps-dot ps-dot--green"></span>
                    Места рядом с вами найдены
                </div>
                <div class="ps-hero-card-line">
                    <span class="ps-dot ps-dot--blue"></span>
                    Средняя цена: <strong>180 ₽/час</strong>
                </div>
                <div class="ps-hero-card-line">
                    <span class="ps-dot ps-dot--yellow"></span>
                    Свободных мест: <strong>{{ spots|length }}</strong>
                </div>
            </div>
        </div>
    </div>
</section>

<section id="search" class="ps-section ps-section--flush-top">
    <div class="ps-section-header">
        <h2 class="ps-section-title">Поиск парковки</h2>
        <p class="ps-section-subtitle">
            Можно искать по городу или точке на карте. На мобильных достаточно нажать
            «Определить моё местоположение».
        </p>
    </div>

    <div class="ps-grid ps-grid--2col@lg ps-grid--gap-xl">
        <div>
            <form method="get" class="ps-card ps-card--elevated ps-form" autocomplete="off">
                <div class="ps-form-row">
                    <label for="city" class="ps-form-label">Город</label>
                    <input id="city"
                           name="city"
                           class="ps-input"
                           placeholder="Москва"
                           value="{{ request.GET.city }}">
                </div>

                <div class="ps-grid ps-grid--2col ps-grid--gap-md">
                    <div class="ps-form-row">
                        <label for="lat" class="ps-form-label">Широта</label>
                        <input id="lat"
                               name="lat"
                               class="ps-input"
                               placeholder="55.75"
                               value="{{ request.GET.lat }}">
                    </div>
                    <div class="ps-form-row">
                        <label for="lng" class="ps-form-label">Долгота</label>
                        <input id="lng"
                               name="lng"
                               class="ps-input"
                               placeholder="37.61"
                               value="{{ request.GET.lng }}">
                    </div>
                </div>

                <div class="ps-form-row">
                    <label for="radius" class="ps-form-label">Радиус поиска, км</label>
                    <input id="radius"
                           name="radius_km"
                           class="ps-input"
                           type="number"
                           step="0.1"
                           min="0.1"
                           value="{{ request.GET.radius_km|default:'1' }}">
                </div>

                <div class="ps-form-actions">
                    <button class="ps-btn ps-btn-lg" type="submit">
                        Найти места
                    </button>
                    <button class="ps-btn ps-btn-secondary ps-btn-lg"
                            type="button"
                            data-fill-location>
                        Использовать моё местоположение
                    </button>
                </div>
            </form>

            <div class="ps-hint ps-animate-fade-up ps-animate-delay-1">
                Совет: после первого поиска PWA запомнит ваш город и будет открываться
                сразу с подходящими предложениями.
            </div>
        </div>

        <div>
            <div id="map" class="ps-map"></div>

            <div class="ps-section-subheader">
                <h3 class="ps-section-title-sm">Доступные места</h3>
            </div>

            <div class="ps-spots-list" data-spots-list>
                <!-- Skeleton при загрузке -->
                <div class="ps-card ps-card--spot ps-card--skeleton">
                    <div class="ps-skeleton-line ps-skeleton-line--lg"></div>
                    <div class="ps-skeleton-line"></div>
                    <div class="ps-skeleton-line ps-skeleton-line--short"></div>
                </div>
                <div class="ps-card ps-card--spot ps-card--skeleton">
                    <div class="ps-skeleton-line ps-skeleton-line--lg"></div>
                    <div class="ps-skeleton-line"></div>
                    <div class="ps-skeleton-line ps-skeleton-line--short"></div>
                </div>

                {% for spot in spots %}
                    <article class="ps-card ps-card--spot ps-animate-fade-up ps-animate-stagger">
                        <div class="ps-card-header">
                            <div class="ps-card-title">
                                {{ spot.lot.city }}, {{ spot.lot.name }} — {{ spot.name }}
                            </div>
                            <span class="ps-badge ps-badge--success">
                                от {{ spot.hourly_price }} ₽/час
                            </span>
                        </div>
                        <div class="ps-card-body">
                            <div class="ps-card-line">
                                Тип: {{ spot.get_vehicle_type_display }}
                                {% if spot.has_ev_charging %}
                                    · зарядка EV
                                {% endif %}
                                {% if spot.is_24_7 %}
                                    · 24/7
                                {% endif %}
                            </div>
                            <div class="ps-card-line ps-card-line--muted">
                                Объект: {{ spot.lot.address }}
                            </div>
                        </div>
                    </article>
                {% empty %}
                    <div class="ps-empty">
                        <p>Подходящих мест пока нет. Попробуйте изменить город или радиус поиска.</p>
                    </div>
                {% endfor %}
            </div>
        </div>
    </div>
</section>
{% endblock %}

{% block extra_scripts %}
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
            crossorigin=""></script>
    <script>
        (function () {
            const mapEl = document.getElementById("map");
            if (!mapEl || typeof L === "undefined") {
                return;
            }

            // Базовый центр — Москва
            const defaultLat = 55.75;
            const defaultLng = 37.61;
            const map = L.map(mapEl).setView([defaultLat, defaultLng], 11);

            L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
                maxZoom: 19,
                attribution: "&copy; OpenStreetMap contributors"
            }).addTo(map);

            const spots = [
                {% for spot in spots %}
                {
                    lat: {{ spot.lot.latitude|default:"null" }},
                    lng: {{ spot.lot.longitude|default:"null" }},
                    title: "{{ spot.lot.city|escapejs }}, {{ spot.lot.name|escapejs }} — {{ spot.name|escapejs }}",
                    price: "{{ spot.hourly_price }}"
                },
                {% endfor %}
            ];

            let bounds = [];
            spots.forEach(function (s) {
                if (s.lat === null || s.lng === null) {
                    return;
                }
                const marker = L.marker([s.lat, s.lng]).addTo(map);
                marker.bindPopup(
                    "<strong>" + s.title + "</strong><br>от " + s.price + " ₽/час"
                );
                bounds.push([s.lat, s.lng]);
            });

            if (bounds.length) {
                map.fitBounds(bounds, {padding: [16, 16]});
            }
        })();
    </script>
{% endblock %}


################################################################################
# File: templates\parking\owner_dashboard.html
################################################################################

{% extends "base.html" %}
{% load static %}

{% block title %}ParkShare RU — кабинет владельца{% endblock %}

{% block content %}
<section class="ps-section">
    <div class="ps-section-header">
        <h1 class="ps-section-title">Кабинет владельца парковок</h1>
        <p class="ps-section-subtitle">
            Управляйте своими объектами, местами и бронированиями в одном интерфейсе.
        </p>
    </div>

    <div class="ps-grid ps-grid--3col@xl ps-grid--gap-xl">
        <div class="ps-grid-span-1">
            <article class="ps-card ps-card--elevated ps-animate-fade-up">
                <div class="ps-card-header">
                    <h2 class="ps-card-title">Мои объекты парковки</h2>
                </div>
                <ul class="ps-list">
                    {% for lot in lots %}
                        <li class="ps-list-item">
                            <div class="ps-list-main">
                                <div class="ps-list-title">
                                    {{ lot.city }}, {{ lot.name }}
                                </div>
                                <div class="ps-list-subtitle">
                                    {{ lot.get_parking_type_display }} · мест: {{ lot.spots.count }}
                                </div>
                            </div>
                            <span class="ps-badge ps-badge--neutral">
                                {{ lot.created_at|date:"d.m.Y" }}
                            </span>
                        </li>
                    {% empty %}
                        <li class="ps-list-empty">
                            Пока нет ни одного объекта. Добавьте парковку через web-интерфейс владельца.
                        </li>
                    {% endfor %}
                </ul>
            </article>

            <article class="ps-card ps-animate-fade-up ps-animate-delay-1">
                <div class="ps-card-header">
                    <h2 class="ps-card-title">Места</h2>
                </div>
                <ul class="ps-list ps-list--compact">
                    {% for spot in spots %}
                        <li class="ps-list-item">
                            <div class="ps-list-main">
                                <div class="ps-list-title">
                                    {{ spot.lot.city }}, {{ spot.lot.name }} — {{ spot.name }}
                                </div>
                                <div class="ps-list-subtitle">
                                    Тип: {{ spot.get_vehicle_type_display }} · {{ spot.hourly_price }} ₽/ч
                                </div>
                            </div>
                            <span class="ps-badge ps-badge--status-{{ spot.status }}">
                                {{ spot.get_status_display }}
                            </span>
                        </li>
                    {% empty %}
                        <li class="ps-list-empty">
                            Мест пока нет.
                        </li>
                    {% endfor %}
                </ul>
            </article>
        </div>

        <div class="ps-grid-span-2">
            <article class="ps-card ps-card--elevated ps-animate-fade-up">
                <div class="ps-card-header">
                    <h2 class="ps-card-title">Бронирования по моим местам</h2>
                </div>
                <div class="ps-table-wrapper">
                    <table class="ps-table">
                        <thead>
                        <tr>
                            <th>Место</th>
                            <th>Пользователь</th>
                            <th>Период</th>
                            <th>Статус</th>
                            <th>Сумма</th>
                        </tr>
                        </thead>
                        <tbody>
                        {% for booking in bookings %}
                            <tr class="ps-animate-fade-up ps-animate-stagger">
                                <td data-label="Место">
                                    {{ booking.spot.lot.city }},
                                    {{ booking.spot.lot.name }} — {{ booking.spot.name }}
                                </td>
                                <td data-label="Пользователь">
                                    {{ booking.user.username }}
                                </td>
                                <td data-label="Период">
                                    {{ booking.start_at|date:"d.m H:i" }} → {{ booking.end_at|date:"d.m H:i" }}
                                </td>
                                <td data-label="Статус">
                                    <span class="ps-badge ps-badge--status-{{ booking.status }}">
                                        {{ booking.get_status_display }}
                                    </span>
                                </td>
                                <td data-label="Сумма">
                                    {{ booking.total_price }} ₽
                                </td>
                            </tr>
                        {% empty %}
                            <tr>
                                <td colspan="5" class="ps-empty">
                                    По вашим местам ещё не было бронирований.
                                </td>
                            </tr>
                        {% endfor %}
                        </tbody>
                    </table>
                </div>
            </article>
        </div>
    </div>
</section>
{% endblock %}


################################################################################
# File: templates\parking\user_dashboard.html
################################################################################

{% extends "base.html" %}
{% load static %}

{% block title %}ParkShare RU — личный кабинет{% endblock %}

{% block content %}
<section class="ps-section">
    <div class="ps-section-header">
        <h1 class="ps-section-title">Личный кабинет водителя</h1>
        <p class="ps-section-subtitle">
            Здесь собраны ваши машины и все активные бронирования.
        </p>
    </div>

    <div class="ps-grid ps-grid--3col@lg ps-grid--gap-xl">
        <div class="ps-grid-span-1">
            <article class="ps-card ps-card--elevated ps-animate-fade-up">
                <div class="ps-card-header">
                    <h2 class="ps-card-title">Профиль</h2>
                </div>
                <div class="ps-card-body">
                    <p class="ps-card-line">
                        <span class="ps-label">Логин:</span> {{ user.username }}
                    </p>
                    <p class="ps-card-line">
                        <span class="ps-label">Роль:</span> {{ user.get_role_display }}
                    </p>
                    <a href="{% url 'accounts:profile' %}" class="ps-btn ps-btn-full">
                        Настройки профиля
                    </a>
                </div>
            </article>

            <article class="ps-card ps-animate-fade-up ps-animate-delay-1">
                <div class="ps-card-header">
                    <h2 class="ps-card-title">Мои машины</h2>
                </div>
                <ul class="ps-list">
                    {% for vehicle in vehicles %}
                        <li class="ps-list-item">
                            <div class="ps-list-main">
                                <div class="ps-list-title">
                                    {{ vehicle.label|default:"Без названия" }}
                                </div>
                                <div class="ps-list-subtitle">
                                    {{ vehicle.get_vehicle_type_display }}
                                </div>
                            </div>
                            <span class="ps-badge ps-badge--neutral">
                                {{ vehicle.created_at|date:"d.m.Y" }}
                            </span>
                        </li>
                    {% empty %}
                        <li class="ps-list-empty">
                            Пока ни одной машины. Добавьте машину через мобильный интерфейс ParkShare RU.
                        </li>
                    {% endfor %}
                </ul>
            </article>
        </div>

        <div class="ps-grid-span-2">
            <article class="ps-card ps-card--elevated ps-animate-fade-up">
                <div class="ps-card-header">
                    <h2 class="ps-card-title">Мои бронирования</h2>
                </div>
                <div class="ps-table-wrapper">
                    <table class="ps-table">
                        <thead>
                        <tr>
                            <th>Место</th>
                            <th>Тип</th>
                            <th>Период</th>
                            <th>Статус</th>
                            <th>Сумма</th>
                        </tr>
                        </thead>
                        <tbody>
                        {% for booking in bookings %}
                            <tr class="ps-animate-fade-up ps-animate-stagger">
                                <td data-label="Место">
                                    {{ booking.spot.lot.city }},
                                    {{ booking.spot.lot.name }} — {{ booking.spot.name }}
                                </td>
                                <td data-label="Тип">
                                    {{ booking.get_booking_type_display }}
                                </td>
                                <td data-label="Период">
                                    {{ booking.start_at|date:"d.m H:i" }} → {{ booking.end_at|date:"d.m H:i" }}
                                </td>
                                <td data-label="Статус">
                                    <span class="ps-badge ps-badge--status-{{ booking.status }}">
                                        {{ booking.get_status_display }}
                                    </span>
                                </td>
                                <td data-label="Сумма">
                                    {{ booking.total_price }} ₽
                                </td>
                            </tr>
                        {% empty %}
                            <tr>
                                <td colspan="5" class="ps-empty">
                                    У вас пока нет бронирований.
                                </td>
                            </tr>
                        {% endfor %}
                        </tbody>
                    </table>
                </div>
            </article>
        </div>
    </div>
</section>
{% endblock %}


################################################################################
# File: vehicles\__init__.py
################################################################################



################################################################################
# File: vehicles\admin.py
################################################################################

# vehicles/admin.py

from django.contrib import admin

from .models import Vehicle


@admin.register(Vehicle)
class VehicleAdmin(admin.ModelAdmin):
    list_display = ("label", "owner", "vehicle_type", "created_at")
    list_filter = ("vehicle_type", "created_at")
    search_fields = ("label", "owner__username")
    readonly_fields = ("plate_hash", "created_at")

    def has_view_or_change_permission(self, request, obj=None):
        """
        В админку по умолчанию имеет доступ только персонал,
        так что дополнительных ограничений не вводим.
        """
        return super().has_view_or_change_permission(request, obj)


################################################################################
# File: vehicles\apps.py
################################################################################

# vehicles/apps.py

from django.apps import AppConfig


class VehiclesConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "vehicles"
    verbose_name = "Машины пользователей"


################################################################################
# File: vehicles\models.py
################################################################################

import uuid

from django.conf import settings
from django.db import models
from django.utils.translation import gettext_lazy as _

from core.models import TimeStampedModel


class Vehicle(TimeStampedModel):
    """
    Машина пользователя.

    Важно:
    - реальный госномер нигде не хранится;
    - в БД есть только хэш цифр номера и произвольная метка (label).
    """

    class VehicleType(models.TextChoices):
        CAR = "car", _("Легковой автомобиль")
        MOTO = "moto", _("Мотоцикл")
        COMMERCIAL = "commercial", _("Коммерческий транспорт")

    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    owner = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name="vehicles",
        verbose_name=_("Владелец"),
    )
    label = models.CharField(
        _("Название/описание"),
        max_length=64,
        blank=True,
        help_text=_("Например: «Серая Toyota у дома»."),
    )
    vehicle_type = models.CharField(
        _("Тип транспорта"),
        max_length=16,
        choices=VehicleType.choices,
        default=VehicleType.CAR,
    )
    plate_hash = models.CharField(
        _("Хэш номера"),
        max_length=64,
        db_index=True,
        help_text=_("SHA‑256‑хэш цифр госномера с солью."),
    )

    class Meta:
        verbose_name = _("Машина")
        verbose_name_plural = _("Машины")
        unique_together = (("owner", "plate_hash"),)
        ordering = ("-created_at",)

    def __str__(self) -> str:
        if self.label:
            return f"{self.label} ({self.owner.username})"
        return f"Машина {self.pk}"


################################################################################
# File: vehicles\serializers.py
################################################################################

# vehicles/serializers.py

from django.utils.translation import gettext_lazy as _
from rest_framework import serializers

from core.utils import hash_plate_digits
from .models import Vehicle


class VehicleSerializer(serializers.ModelSerializer):
    """
    Сериализатор для машин.

    Вход:
    - plate_number (write_only) — строка номера, хэшируется на сервере;
    - label, vehicle_type.

    Выход:
    - id, label, vehicle_type, created_at.
    """

    plate_number = serializers.CharField(
        write_only=True,
        label=_("Госномер"),
        help_text=_(
            "Фактический номер будет преобразован в хэш и не будет храниться в открытом виде."
        ),
    )

    class Meta:
        model = Vehicle
        fields = ("id", "label", "vehicle_type", "plate_number", "created_at")
        read_only_fields = ("id", "created_at")

    def validate_plate_number(self, value: str) -> str:
        digits = "".join(ch for ch in value if ch.isdigit())
        if not digits:
            raise serializers.ValidationError(
                _("Нужно указать хотя бы одну цифру номера.")
            )
        return value

    def create(self, validated_data: dict) -> Vehicle:
        request = self.context["request"]
        user = request.user
        plate_number = validated_data.pop("plate_number")
        plate_hash = hash_plate_digits(plate_number)
        if Vehicle.objects.filter(owner=user, plate_hash=plate_hash).exists():
            raise serializers.ValidationError(
                {
                    "plate_number": _(
                        "Машина с таким номером уже добавлена в ваш список."
                    )
                }
            )
        vehicle = Vehicle.objects.create(
            owner=user,
            plate_hash=plate_hash,
            **validated_data,
        )
        return vehicle

    def update(self, instance: Vehicle, validated_data: dict) -> Vehicle:
        # Номер менять нельзя (потребует создания нового объекта),
        # поэтому игнорируем plate_number при обновлении.
        validated_data.pop("plate_number", None)
        return super().update(instance, validated_data)


################################################################################
# File: vehicles\urls.py
################################################################################

# vehicles/urls.py

from django.contrib.auth.decorators import login_required
from django.urls import path
from django.views.generic import TemplateView

app_name = "vehicles"

urlpatterns = [
    # Простая HTML-страница «Мои машины» (можно использовать в будущем).
    path(
        "my/",
        login_required(
            TemplateView.as_view(template_name="vehicles/my_vehicles.html")
        ),
        name="my_vehicles",
    ),
]


################################################################################
# File: vehicles\views.py
################################################################################

# vehicles/views.py

from rest_framework import permissions, viewsets

from core.permissions import IsOwnerObject
from .models import Vehicle
from .serializers import VehicleSerializer


class VehicleViewSet(viewsets.ModelViewSet):
    """
    API для машин пользователя.

    - /api/vehicles/              (GET)   — список машин текущего пользователя
    - /api/vehicles/              (POST)  — создать машину (номер хэшируется)
    - /api/vehicles/{id}/         (GET)   — детали (только владелец)
    - /api/vehicles/{id}/         (PATCH/PUT/DELETE) — управление машиной (только владелец)
    """

    serializer_class = VehicleSerializer
    permission_classes = [permissions.IsAuthenticated, IsOwnerObject]

    def get_queryset(self):
        user = self.request.user
        if not user.is_authenticated:
            return Vehicle.objects.none()
        return Vehicle.objects.filter(owner=user).order_by("-created_at")

    def perform_create(self, serializer: VehicleSerializer) -> None:
        # owner устанавливается в serializer.create()
        serializer.save()


################################################################################
# File: vehicles\migrations\0001_initial.py
################################################################################

# Generated by Django 5.2.8 on 2025-11-21 21:34

import django.db.models.deletion
import uuid
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='Vehicle',
            fields=[
                ('created_at', models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')),
                ('updated_at', models.DateTimeField(auto_now=True, verbose_name='Дата обновления')),
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('label', models.CharField(blank=True, help_text='Например: «Серая Toyota у дома».', max_length=64, verbose_name='Название/описание')),
                ('vehicle_type', models.CharField(choices=[('car', 'Легковой автомобиль'), ('moto', 'Мотоцикл'), ('commercial', 'Коммерческий транспорт')], default='car', max_length=16, verbose_name='Тип транспорта')),
                ('plate_hash', models.CharField(db_index=True, help_text='SHA‑256‑хэш цифр госномера с солью.', max_length=64, verbose_name='Хэш номера')),
                ('owner', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='vehicles', to=settings.AUTH_USER_MODEL, verbose_name='Владелец')),
            ],
            options={
                'verbose_name': 'Машина',
                'verbose_name_plural': 'Машины',
                'ordering': ('-created_at',),
                'unique_together': {('owner', 'plate_hash')},
            },
        ),
    ]


################################################################################
# File: vehicles\migrations\__init__.py
################################################################################



